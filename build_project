#!/bin/bash -e

debug_mode="true"
debug_mode="false"

# TODO -- Add --heroku option for:
#               build
#               db_reset
#               deploy?


# Reinstall all gems...
# uninstall() {
#   list=`gem list --no-versions`
#   for gem in $list; do
#     gem uninstall $gem -aIx
#   done
#   gem list
#   gem install bundler
# }
#
# #rbenv versions --bare
# RBENVPATH=`rbenv root`
# echo $RBENVPATH
# RUBIES=`ls $RBENVPATH/versions`
# for ruby in $RUBIES; do
#   echo '---------------------------------------'
#   echo $ruby
#   rbenv local $ruby
#   uninstall
# done




function load_project_settings
{
  exe_name="${1}"
  # Default values based on the system being build for the Sparrow project.
  # sparrow
  project_base_name="sparrow"
  # Sparrow/
  project_base_parent_dir="Sparrow/"
  # SageACT
  project_repository_name="SageACT"
  # sparrow_host
  project_app_directory="sparrow_host"

  # build_project
  proj_dir="${exe_name:0:$((${#exe_name} - 13))}"

  if [ -f ${proj_dir}/settings_for_build_project ]; then
    settings_lines=$(cat ${proj_dir}/settings_for_build_project)
    while read exec_setting_val; do
      eval ${exec_setting_val}
    done <<< "${settings_lines}"
  fi
}

load_project_settings "${0}"

# Todo:
#   undo commit # git reset --hard HEAD~1
#   git merge --abort

# global variables...
declare -a branches
declare -a command_descriptions
declare -a command_options_show
declare -a command_options
declare -a command_vars
declare -a additional_params

time_format_sting="+%Y-%m-%d-%H-%M-%S"
merge_conflict_status_grep="^\(DD\|AA\|.U\|U.\)"

test_param_test_number=""
test_param_test_line=""

smoke_browser_set="false"
local_branch=-1
local_branch_name="master"
command_line_arguments=("$@")
current_directory="$(pwd)"
rails_env_to_use="development"
return_line="
"
tab_character="	"

build_base_directory="${current_directory}/${project_base_name}"
build_parent_directory="${current_directory}"
build_log_directory="${build_parent_directory}/BuildLogs"

# The script was originally built "outside" the project directory, and I like it that way
# however in order to be able to check it in, it needs to be in the project directory,
# and should therefore be able to run there.
#
# So, the script works on 3 levels:
#
#   1) It can be run directly from the project folder.
#   2) It can be run from the directory that contains the project folder
#   3) It can be run from the directory I like which contains a directory
#       named "<project name>" that then contains the project itself.

if [ -d "${current_directory}/.git" ]; then
  if [ -f "${current_directory}/.git/config" ]; then
    project_is_local="false"
    if ! grep -q "git@github.com:${project_repository_name}/${project_base_name}.git" ${current_directory}/.git/config; then
      project_is_local="true"
    fi
    if ! grep -q "https://github.com/${project_repository_name}/${project_base_name}.git" ${current_directory}/.git/config; then
      project_is_local="true"
    fi

    if [ "${project_is_local}" = "true" ]; then
      build_base_directory=${current_directory}
      cd ..
      build_parent_directory="$(pwd)"
      cd ${build_base_directory}
    fi
  fi
fi

if [ ! -d "${build_base_directory}/.git" ]; then
  if [ -d "${current_directory}/${project_base_parent_dir}${project_base_name}/.git" ]; then
    build_base_directory="${current_directory}/${project_base_parent_dir}${project_base_name}"
    build_parent_directory="${current_directory}/${project_base_parent_dir}"
  fi
fi
build_log_directory="${build_parent_directory}/BuildLogs"

function initialize_commands
{
  # We initialize the the list of commands into an array so that
  # we can easily add new commands and parse them here.
  # Having them in the array also simplifies the help screen and
  # a command prompt option.

  # -b, --build                   - Build the project
  # -t, --test                    - Run tests
  # -p, --pull                    - Pull the source
  # -m, --merge                   - Merge a branch
  # -h, --push                    - Push committed changes to GitHub
  # -u, --status                  - Just do a git status on the current branch...
  # -n, --new_branch --new-branch - Create a branch
  # -?, --help                    - Show help
  # -s, --switch                  - Switch branches
  # -d, --delete                  - Delete a branch
  # -g, --guard                   - Launch Gaurd continuous testing
  # -e, --reset_db --reset-db     - Delete and reset/recreate DBs
  # -c, --console                 - Run the Rails console
  # -r, --run                     - Run the application
  # -v, --move                    - Move the current git directory out of the way
  # -l, --clone                   - Clone the repository
  # -o, --production              - Production Deployment
  # --base_dir --base-dir         - The base directory to work in (the parent to the project)
  # --rails_env --rails-env       - The RAILS_ENV to use for build/deploy
  # -y --deploy                   - Deploy the system to one of the known machines
  # --history                     - Show recent history
  # --stash_locks --stash-locks   - Backup the Gemfile.lock files that are not checked in
  # ---stash                      - Menuized version of git stash
  # --stash                       - Stash the current branch
  # --drop_stash --drop-stash     - Drop a stash
  # --unstash                     - Apply a stash
  # --reset_git --reset-git       - Do a hard reset
  # --smoke                       - Do a partial test of only running the ci:smoke.
  # ---test                       - Menuized testing options
  # --test_params --test-params   - Parameters for running the menuized tests in the form of "<test number>[:<line_number>]"
  # --check-merge --check_merge   - Uses git-status to validate/check/add and finally commit files with merge conflicts
  # --db-dump --db_dump           - Drop the test databases and recreate them to dump the schema into the schema.rb file.
  # --db-branch --db_branch       - Configure wether or not the database is branched as well.
  # --clean                       - Do a clean of the git repository...
  # --patch                       - Create a patch file
  # --apply-patch                 - Apply a patch to the current branch.
  # --list                        - List branches
  # --reset-build-cache           - Reset the cache of build information to force the bundle instal to run.

  # If this has been called before, don't do it again...
  if [ "${#command_vars[@]}" -le "0" ]; then
    # -b, --build                   - Build the project
    command_vars[${#command_vars[@]}]="do_build_project"
    command_options_show[${#command_options_show[@]}]="-b --build"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Build ${project_base_name}"

    # -t, --test                    - Run tests
    command_vars[${#command_vars[@]}]="do_run_tests"
    command_options_show[${#command_options_show[@]}]="-t --test"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Run tests"

    # -p, --pull                    - Pull the source
    command_vars[${#command_vars[@]}]="do_pull_source"
    command_options_show[${#command_options_show[@]}]="-p --pull"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Pull the source"

    # -m, --merge                   - Merge a branch
    command_vars[${#command_vars[@]}]="do_merge"
    command_options_show[${#command_options_show[@]}]="-m --merge"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Merge a branch"

    # -h, --push                    - Push committed changes to GitHub
    command_vars[${#command_vars[@]}]="do_push_source"
    command_options_show[${#command_options_show[@]}]="-h --push"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Push committed changes to GitHub"

    # -u, --status                  - Just do a git status on the current branch...
    command_vars[${#command_vars[@]}]="do_show_status"
    command_options_show[${#command_options_show[@]}]="-u --status"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Just do a git status on the current branch..."

    # -n, --new_branch --new-branch - Create a branch
    command_vars[${#command_vars[@]}]="do_create_branch"
    command_options_show[${#command_options_show[@]}]="-n --new_branch"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --new-branch --new"
    command_descriptions[${#command_descriptions[@]}]="Create a branch"

    # -?, --help                    - Show help
    command_vars[${#command_vars[@]}]="show_help"
    command_options_show[${#command_options_show[@]}]="-? --help"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Show help"

    # -s, --switch                  - Switch branches
    command_vars[${#command_vars[@]}]="do_switch"
    command_options_show[${#command_options_show[@]}]="-s --switch"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Switch branches"

    # -d, --delete                  - Delete a branch
    command_vars[${#command_vars[@]}]="do_delete_branch"
    command_options_show[${#command_options_show[@]}]="-d --delete"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Delete a branch"

    # -g, --guard                   - Launch Gaurd continuous testing
    command_vars[${#command_vars[@]}]="do_start_guard"
    command_options_show[${#command_options_show[@]}]="-g --guard"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Launch Gaurd continuous testing"

    # -e, --reset_db --reset-db     - Delete and reset/recreate DBs
    command_vars[${#command_vars[@]}]="do_reset_db"
    command_options_show[${#command_options_show[@]}]="-e --reset_db"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --reset-db"
    command_descriptions[${#command_descriptions[@]}]="Delete and reset/recreate DBs"

    # -c, --console                 - Run the Rails console
    command_vars[${#command_vars[@]}]="do_launch_console"
    command_options_show[${#command_options_show[@]}]="-c --console"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Run the Rails console"

    # -r, --run                     - Run the application
    command_vars[${#command_vars[@]}]="do_run_site"
    command_options_show[${#command_options_show[@]}]="-r --run"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Run the application"

    # -v, --move                    - Move the current git directory out of the way
    command_vars[${#command_vars[@]}]="do_move_site"
    command_options_show[${#command_options_show[@]}]="-v --move"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Move the current git directory out of the way"

    # -l, --clone                   - Clone the repository
    command_vars[${#command_vars[@]}]="do_clone"
    command_options_show[${#command_options_show[@]}]="-l --clone"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Clone the repository"

    # -o, --production              - Production Deployment
    command_vars[${#command_vars[@]}]="do_production_deployment"
    command_options_show[${#command_options_show[@]}]="-o --production"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Production Deployment"

    # --base_dir --base-dir         - The base directory to work in
    command_vars[${#command_vars[@]}]="set_base_dir base_dir_param"
    command_options_show[${#command_options_show[@]}]="--base_dir"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --base-dir"
    command_descriptions[${#command_descriptions[@]}]="The base directory to work in (the parent to ${project_base_name})"

    # --rails_env --rails-env       - The RAILS_ENV to use for build/deploy
    command_vars[${#command_vars[@]}]="change_rails_env rails_env_param"
    command_options_show[${#command_options_show[@]}]="--rails_env"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --rails-env"
    command_descriptions[${#command_descriptions[@]}]="The RAILS_ENV to use for build/deploy"

    # -y --deploy                   - Deploy the system to one of the known machines
    command_vars[${#command_vars[@]}]="do_deploy"
    command_options_show[${#command_options_show[@]}]="-y --deploy"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Deploy the system to one of the known machines"

    # --history                     - Show recent history
    command_vars[${#command_vars[@]}]="do_show_history"
    command_options_show[${#command_options_show[@]}]="--history"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Show recent history"

    # --stash_locks --stash-locks   - Backup the Gemfile.lock files that are not checked in
    command_vars[${#command_vars[@]}]="do_stash_lockfiles"
    command_options_show[${#command_options_show[@]}]="--stash_locks"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --stash-locks"
    command_descriptions[${#command_descriptions[@]}]="Backup the Gemfile.lock files that are not checked in"

    # ---stash                      - Menuized version of git stash
    command_vars[${#command_vars[@]}]="do_stash_menu"
    command_options_show[${#command_options_show[@]}]="---stash"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Menuized version of git stash"

    # --stash                       - Stash the current branch
    command_vars[${#command_vars[@]}]="do_stash_command"
    command_options_show[${#command_options_show[@]}]="--stash"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Stash the current branch"

    # --drop_stash --drop-stash     - Drop a stash
    command_vars[${#command_vars[@]}]="do_stash_drop"
    command_options_show[${#command_options_show[@]}]="--drop_stash"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --drop-stash"
    command_descriptions[${#command_descriptions[@]}]="Drop a stash"

    # --unstash                     - Apply a stash
    command_vars[${#command_vars[@]}]="do_stash_unstash"
    command_options_show[${#command_options_show[@]}]="--unstash"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Apply a stash"

    # --reset_git --reset-git       - Do a hard reset
    command_vars[${#command_vars[@]}]="do_git_reset"
    command_options_show[${#command_options_show[@]}]="--reset_git"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --reset-git --reset"
    command_descriptions[${#command_descriptions[@]}]="Do a hard reset"

    # --smoke                       - Do a partial test of only running the ci:smoke.
    command_vars[${#command_vars[@]}]="do_cucumber_smoke"
    command_options_show[${#command_options_show[@]}]="--smoke"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Do a partial test of only running the ci:smoke."

    # ---test                       - Menuized testing options
    command_vars[${#command_vars[@]}]="do_test_menu"
    command_options_show[${#command_options_show[@]}]="---test"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Menuized testing options"

    # --test_params --test-params   - Parameters for running the menuized tests in the form of "<test number>[:<line_number>]"
    command_vars[${#command_vars[@]}]="use_menu_test_parameters menu_test_param_value"
    command_options_show[${#command_options_show[@]}]="--test_params"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --test-params"
    command_descriptions[${#command_descriptions[@]}]="Parameters for running the menuized tests in the form of \"<test number>[:<line_number>]\""

    # --check-merge --check_merge   - Uses git-status to validate/check/add and finally commit files with merge conflicts
    command_vars[${#command_vars[@]}]="do_merge_validation"
    command_options_show[${#command_options_show[@]}]="--check_merge"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --check-merge --merge-check --merge_check"
    command_descriptions[${#command_descriptions[@]}]="Uses git-status to validate/check/add and finally commit files with merge conflicts"

    # --db-dump --db_dump           - Drop the test databases and recreate them to dump the schema into the schema.rb file.
    command_vars[${#command_vars[@]}]="do_schema_recreate"
    command_options_show[${#command_options_show[@]}]="--db_dump"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --db-dump"
    command_descriptions[${#command_descriptions[@]}]="Drop the test databases and recreate them to dump the schema into the schema.rb file."

    # --db-branch --db_branch       - Configure wether or not the database is branched as well.
    command_vars[${#command_vars[@]}]="do_database_branching"
    command_options_show[${#command_options_show[@]}]="--db_branch"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --db-branch --branch-db --branch_db"
    command_descriptions[${#command_descriptions[@]}]="Configure wether or not the database is branched as well."

    # --clean                       - Do a clean of the git repository...
    command_vars[${#command_vars[@]}]="do_database_clean"
    command_options_show[${#command_options_show[@]}]="--clean"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Do a clean of the git repository..."

    # --patch                       - Create a patch file
    command_vars[${#command_vars[@]}]="do_create_patch create_patch_file_name"
    command_options_show[${#command_options_show[@]}]="--patch"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="Create a patch file"

    # --apply-patch                 - Apply a patch to the current branch.
    command_vars[${#command_vars[@]}]="do_apply_patch apply_patch_file_name"
    command_options_show[${#command_options_show[@]}]="--apply"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --apply-patch"
    command_descriptions[${#command_descriptions[@]}]="Apply a patch to the current branch."

    # --list                        - List branches
    command_vars[${#command_vars[@]}]="do_list_branches"
    command_options_show[${#command_options_show[@]}]="--list"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]}"
    command_descriptions[${#command_descriptions[@]}]="List branches"

    # --reset-build-cache           - Reset the cache of build information to force the bundle instal to run.
    command_vars[${#command_vars[@]}]="do_reset_build_cache_files"
    command_options_show[${#command_options_show[@]}]="--reset-build-cache"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --reset_build_cache"
    command_descriptions[${#command_descriptions[@]}]="Reset the cache of build information to force the bundle instal to run."

    # --smoke-params                - Parameters to pass into the smoke
    command_vars[${#command_vars[@]}]="do_set_smoke_params user_smoke_params"
    command_options_show[${#command_options_show[@]}]="--smoke-params"
    command_options[${#command_options[@]}]="${command_options_show[$((${#command_options_show[@]} - 1))]} --smoke_params"
    command_descriptions[${#command_descriptions[@]}]="Parameters to pass into the smoke"
  fi
}

function append_array_value
{
  # This funciton appends the passed in value to an array.
  #
  # PARAMETERS:
  #   ${1}  - array_append_var  - The array variable to append to.
  #   ${2}  - array_append_val  - The value to append to the array.

  array_append_var="${1}"
  array_append_val="${2}"

  # OK, I admit it, I don't really know why this line works exactly, but it does
  # and I couldn't figure out something that would work the way I wanted it to
  # so, I'm just leaving it as is.
  #
  # if you put "'s arond the line here, it breaks because the string may contain
  # "s, which ends the string and breaks it.
  # This line works because we have a string that we set using:
  # '<string>'
  # If <string> == <string 1>'<string 2>, it is changed to:
  # '<string 1>'"'"'<string 2>' which is interpreted as the concatination of 3 strings
  # which results in:
  # <string 1>'<string 2>
  array_append_val=${array_append_val//\'/\'\"\'\"\'}

  eval ${array_append_var}[\${#${array_append_var}[@]}]="'${array_append_val}'"
}

function set_param_value
{
  # This funciton sets the passed in value to a variable.
  #
  # PARAMETERS:
  #   ${1}  - set_var - The array variable to append to.
  #   ${2}  - set_val - The value to append to the array.

  set_var="${1}"
  set_val="${2}"

  # OK, I admit it, I don't know why this line works exactly, but it does
  # and I couldn't figure out something that would work the way I wanted it to
  # so, I'm just leaving it as is.
  # if you put "'s arond the line here, it breaks.
  # set_val=${set_val//\"/\\\"}
  set_val=${set_val//\'/\'\"\'\"\'}
  eval ${set_var}="'${set_val}'"
}

function execute_command
{
  # This executes a command and echos the output.
  #
  # NOTE: The value of success_return_var may not be accurate if the
  #       value of file_to_echo_to is set.
  #
  #       If file_to_echo_to is used, you should parse the output
  #       to validate success.
  #
  # PARAMETERS:
  #   ${1}  - command_to_execute      - The command to execute
  #   ${2}  - file_to_echo_to         - A file to output the text into.
  #   ${3}  - success_return_var      - The variable to return the success/failure in
  #   ${4}  - execute_text_return_var - The variable to return the text in

  command_to_execute="${1}"
  file_to_echo_to="${2}"
  success_return_var="${3}"
  execute_text_return_var="${4}"

  if [ ! -z "${file_to_echo_to}" ]; then
    echo "$(pwd) \$ ${command_to_execute}" 2>&1 | tee -a ${file_to_echo_to}
  else
    echo "$(pwd) \$ ${command_to_execute}"
  fi

  if [ ! -z "${file_to_echo_to}" ]; then
    command_to_execute="${command_to_execute} 2>&1 | tee -a ${file_to_echo_to}"
  fi
  if [ ! -z "${execute_text_return_var}" ]; then
    command_to_execute="execute_text=\$(${command_to_execute}"
    if [ -z "${file_to_echo_to}" ]; then
      command_to_execute="${command_to_execute} 2>&1"
    fi
    command_to_execute="${command_to_execute})"
  fi

  if [ ! -z "${success_return_var}" ]; then
    set +e
  fi
  eval "${command_to_execute}"
  execute_command_successful="${?}"
  if [ ! -z "${success_return_var}" ]; then
    set -e
  fi
  if [ ! -z "${execute_text_return_var}" ]; then
    echo "${execute_text}"
  fi

  if [ ! -z "${success_return_var}" ]; then
    set_param_value "${success_return_var}" "${execute_command_successful}"
  fi
  if [ ! -z "${execute_text_return_var}" ]; then
    set_param_value "${execute_text_return_var}" "${execute_text}"
  fi
}

function heroku_run
{
  # This function executes heroku run for the passed in command.
  # This allows for problems with fire-walls by checking if the initial
  # run fails, and if so, does the run in an alternate form.
  #
  # PARAMETERS:
  #   ${1}  - heroku_run_command  - The command to run.
  #   ${2}  - heroku_run_log_file - The log file to output information to.

  heroku_run_command="${1}"
  heroku_run_log_file="${2}"

  heroku_run_success="1"

  backup_outputs "${build_log_directory}" "single_heroku_deploy.txt" "1w" "7 days"
  execute_command "heroku run ${heroku_run_command}" "${build_log_directory}/single_heroku_deploy.txt" heroku_run_success ""
  cat ${build_log_directory}/single_heroku_deploy.txt >> ${heroku_run_log_file}

  if [ "${heroku_run_success}" = "0" ]; then
    if grep "Error connecting to process" ${build_log_directory}/single_heroku_deploy.txt; then
      heroku_run_success="1"
    fi
  fi

  if [ "${heroku_run_success}" != "0" ]; then
    execute_command "heroku run:detached ${heroku_run_command}" "${build_log_directory}/single_heroku_deploy.txt" heroku_run_success heroku_run_text
    cat ${build_log_directory}/single_heroku_deploy.txt >> ${heroku_run_log_file}
    run_heroku_log=$(grep "Use \`heroku" ${build_log_directory}/single_heroku_deploy.txt)
    split_line_on_char "${run_heroku_log}" "\`" run_heroku_ignore_text run_heroku_log
    split_line_on_char "${run_heroku_log}" "\`" run_heroku_log run_heroku_ignore_text

    heroku_prev_process_id="${run_heroku_log}"
    while [ ! -z "${heroku_prev_process_id}" ]; do
      heroku_process_id="${heroku_prev_process_id}"
      split_line_on_char "${heroku_prev_process_id}" " " run_heroku_ignore_text heroku_prev_process_id
    done

    while heroku ps | grep "${heroku_process_id}"; do
      sleep 1
    done

    execute_command "${run_heroku_log}" "" "" ""
  fi
}

function yes_no_prompt
{
  # This function presents the user with a y/n message and reads the response.
  # The response is validated, and if blank either the user is re-prompted or
  # a default value is used if supplied.
  # This function will only return y or n.
  #
  # PARAMETERS:
  #   ${1}  - yes_no_prompt_text
  #   ${2}  - yes_no_default_value
  #   ${3}  - yes_no_selected_value_var

  yes_no_prompt_text="${1}"
  yes_no_default_value="${2}"
  yes_no_selected_value_var="${3}"

  # default may only be y or n
  if [ ! -z "${yes_no_default_value}" ]; then
    if [ "${yes_no_default_value:0:1}" = "(" ]; then
      yes_no_default_value=""
    else
      if [ "${yes_no_default_value:0:1}" = ")" ]; then
        yes_no_default_value=""
      fi
    fi
  fi
  if [ ! -z "${yes_no_default_value}" ]; then
    if [ "${yes_no_default_value:0:1}" = "Y" -o "${yes_no_default_value:0:1}" = "y" ]; then
      yes_no_default_value="y"
    else
      if [ "${yes_no_default_value:0:1}" = "N" -o "${yes_no_default_value:0:1}" = "n" ]; then
        yes_no_default_value="n"
      else
        yes_no_default_value=""
      fi
    fi
  fi

  yes_no_selected_val=""
  format_line "${yes_no_prompt_text}" "" yes_no_prompt_text
  while [ -z "${yes_no_selected_val}" ]; do
    read -p "${yes_no_prompt_text}" yes_no_user_input
    echo ""
    if [ -z "${yes_no_user_input}" ]; then
      yes_no_user_input="${yes_no_default_value}"
    fi
    if [ ! -z "${yes_no_user_input}" ]; then
      if [ "${yes_no_user_input:0:1}" = "(" ]; then
        yes_no_user_input="x"
      fi
      if [ "${yes_no_user_input:0:1}" = ")" ]; then
        yes_no_user_input="x"
      fi
    fi
    if [ ! -z "${yes_no_user_input}" ]; then
      if [ "${yes_no_user_input:0:1}" = "Y" -o "${yes_no_user_input:0:1}" = "y" ]; then
        yes_no_selected_val="y"
      else
        if [ "${yes_no_user_input:0:1}" = "N" -o "${yes_no_user_input:0:1}" = "n" ]; then
          yes_no_selected_val="n"
        fi
      fi
    fi
  done

  set_param_value "${yes_no_selected_value_var}" "${yes_no_selected_val}"
}

function update_origin_branch
{
  # This function edits the .git/config file to change the
  # "merge" for a branch from master to the branch of the same name
  #
  # This is so that when manual commands are executed not through the
  # script, they will work as though through the script if something is
  # dropped off...
  #
  # [branch "master"]
  #   remote = origin
  #   merge = refs/heads/master
  #
  # PARAMETERS:
  #   ${1}  - update_local_name   - The local branch name
  #   ${2}  - update_remote_name  - The remote branch name

  cd ${build_base_directory}

  update_local_name="${1}"
  update_remote_name="${2}"

  record_branch update_origin_branch_name

  if [ -z "${update_local_name}" ]; then
    update_local_name="${update_origin_branch_name}"
  fi
  if [ -z "${update_remote_name}" ]; then
    get_origin_branch "${update_local_name}" "push" "true" update_remote_name
  fi

  set +e
  merge_config="$(git config branch.${update_local_name}.merge)"
  set -e

  if [ "${merge_config}" = "refs/heads/master" -o -z "${merge_config}" ]; then
    execute_command "git config branch.${update_local_name}.merge \"refs/heads/${update_remote_name}\"" "" "" ""
  fi
}

function get_origin_branch
{
  # This function gets the origin branch for the specified branch.
  # It does this by querying git with git remote show origin and if it
  # cannot find th origin that way, it will guess and provide a default.
  # The default is: origin/<branch_name>
  #
  # PARAMETERS:
  #   ${1}  - find_origin_for_branch_name - The name of the branch we are querying on
  #   ${2}  - origin_find_action          - The action (pull/push) to look for the origin for
  #   ${3}  - origin_find_allow_default   - true/false if a default value may be returned
  #   ${4}  - found_origin_name_var       - The origin name that was found (if any)

  find_origin_for_branch_name="${1}"
  origin_find_action="${2}"
  origin_find_allow_default="${3}"
  found_origin_name_var="${4}"

  # This code was from before I learned about git config branch.<branch>.[merge|push|pull]
  # # Sample output:
  # # * remote origin
  # #   Fetch URL: git@github.com:SageACT/s parrow.git
  # #   Push  URL: git@github.com:SageACT/s parrow.git
  # #   HEAD branch: master
  # #   Remote branches:
  # #     B-03837-linkedin_basic_feed          tracked
  # #   Local branches configured for 'git pull':
  # #     B-03837-linkedin_basic_feed     merges with remote B-03837-linkedin_basic_feed
  # #   Local refs configured for 'git push':
  # #     B-03837-linkedin_basic_feed     pushes to B-03837-linkedin_basic_feed     (local out of date)

  # set +e
  # origin_information="$(git remote show origin)"
  # origin_information_available="${?}"
  # set -e

  # if [ "${origin_information_available}" != "0" ]; then
  #   # Ideally we would support pull and push, but for efficiencies
  #   # I assume that push and pull will go to the same place, so I can
  #   # use cached information.
  #   origin_find_action="pull"
  #   origin_information="$(git remote show -n origin)"
  # fi

  # in_get_origin_section="false"
  # get_remote_branch_name=""
  # while read origin_info_line; do
  #   if [ "${in_get_origin_section}" = "true" ]; then
  #     if [ "${origin_info_line}" = "Local branches configured for 'git pull':" ]; then
  #       in_get_origin_section="false"
  #     else
  #       if [ "${origin_info_line}" = "Local refs configured for 'git push':" ]; then
  #         in_get_origin_section="false"
  #       fi
  #     fi
  #   fi

  #   if [ "${in_get_origin_section}" = "true" ]; then
  #     split_line_on_char "${origin_info_line:4}" " " get_origin_branch_name git_origin_merges_with
  #     if [ "${get_origin_branch_name}" = "${find_origin_for_branch_name}" ]; then
  #       ltrim_line "${git_origin_merges_with}" git_origin_merges_with
  #       if [ ${#git_origin_merges_with} -gt 10 ]; then
  #         if [ "${git_origin_merges_with:0:10}" = "pushes to " ]; then
  #           git_origin_merges_with="${git_origin_merges_with:10}"
  #         fi
  #       fi
  #       if [ ${#git_origin_merges_with} -gt 12 ]; then
  #         if [ "${git_origin_merges_with:0:12}" = "merges with " ]; then
  #           git_origin_merges_with="${git_origin_merges_with:12}"
  #         fi
  #       fi
  #       split_line_on_char "${git_origin_merges_with}" " " get_remote_branch_name remote_branch_status

  #       break
  #     fi
  #   fi
  #   if [ "${origin_info_line}" = "Local branches configured for 'git ${origin_find_action}':" ]; then
  #       in_get_origin_section="true"
  #   else
  #     if [ "${origin_info_line}" = "Local refs configured for 'git ${origin_find_action}':" ]; then
  #       in_get_origin_section="true"
  #     fi
  #   fi
  # done <<< "${origin_information}"

  set +e
  get_remote_branch_name="$(git config branch.${find_origin_for_branch_name}.merge)"
  set -e
  if [ -z "${get_remote_branch_name}" ]; then
    set +e
    get_remote_branch_name="$(git config branch.${find_origin_for_branch_name}.${origin_find_action})"
    set -e
  fi
  if [ ${#get_remote_branch_name} -gt 11 ]; then
    if [ "${get_remote_branch_name:0:11}" = "refs/heads/" ]; then
      get_remote_branch_name="${get_remote_branch_name:11}"
    fi
  fi

  # We don't want to return master unless we are on the master branch.
  if [ "${get_remote_branch_name}" = "master" ]; then
    if [ "${find_origin_for_branch_name}" != "master" ]; then
      get_remote_branch_name=""
    fi
  fi

  if [ -z "${get_remote_branch_name}" ]; then
    # couldn't find the remote by searching through git remote show origin.
    # try looking at remote branches and find it there...
    # If we find a properly named branch, assume the branch was created "badly"
    # and the intent is to use the same named branch.

    initialize_branch_information false true false
    get_origin_branch_index=0
    while [ ${get_origin_branch_index} -lt ${#branches[@]} ]; do
      if [ "${branches[${get_origin_branch_index}]}" = "origin/${find_origin_for_branch_name}" ]; then
        get_remote_branch_name="${branches[${get_origin_branch_index}]:7}"
        break
      fi
      get_origin_branch_index=$((${get_origin_branch_index} + 1))
    done
  fi

  if [ -z "${get_remote_branch_name}" ]; then
    if [ "${origin_find_allow_default}" = "true" ]; then
      get_remote_branch_name="${find_origin_for_branch_name}"
    fi
  fi

  set_param_value "${found_origin_name_var}" "${get_remote_branch_name}"
}

function format_line
{
  # This function wraps a line of text for nice output.
  #
  # PARAMETERS:
  #   ${1}  - format_line_text    - The line to format
  #   ${2}  - format_indent_text  - Prefix text to put in front of wrapped lines
  #   ${3}  - formatted_line_var  - The variable to return the formatted text

  format_line_with_prefix "" "${1}" "${2}" "${3}"
}

function format_line_with_prefix
{
  # This function wraps a line of text for nice output.
  #
  # PARAMETERS:
  #   ${1}  - multi_format_line_prefix  - The prefix to add to the first line.
  #   ${2}  - multi_format_line_text    - The line to format
  #   ${3}  - multi_format_indent_text  - Prefix text to put in front of wrapped lines
  #   ${4}  - multi_formatted_line_var  - The variable to return the formatted text

  multi_format_line_prefix="${1}"
  multi_format_line_text="${2}"
  multi_format_indent_text="${3}"
  multi_formatted_line_var="${4}"

  declare -a lines_to_format

  while [ ! -z "${multi_format_line_text}" ]; do
    split_line_on_char "${multi_format_line_text}" "${return_line}" first_line_found multi_format_line_text
    lines_to_format[${#lines_to_format[@]}]="${first_line_found}"
    total_lines_to_format=$((${total_lines_to_format} - 1))
  done

  final_format_text=""
  format_line_index=0
  while [ ${format_line_index} -lt ${#lines_to_format[@]} ]; do
    if [ ${#multi_format_line_prefix} -lt ${#lines_to_format[${format_line_index}]} ]; then
      if [ "${multi_format_line_prefix}" = "${lines_to_format[${format_line_index}]:0:${#multi_format_line_prefix}}" ]; then
        lines_to_format[${format_line_index}]="${lines_to_format[${format_line_index}]:${#multi_format_line_prefix}}"
      fi
    fi
    format_single_line_with_prefix "${multi_format_line_prefix}" "${lines_to_format[${format_line_index}]}" "${multi_format_indent_text}" mutlit_line_sub_text
    if [ ! -z "${final_format_text}" ]; then
      final_format_text="${final_format_text}${return_line}"
    fi
    final_format_text="${final_format_text}${mutlit_line_sub_text}"

    multi_format_line_prefix="${multi_format_indent_text}"
    format_line_index=$((${format_line_index} + 1))
  done

  set_param_value "${multi_formatted_line_var}" "${final_format_text}"
}

function format_single_line_with_prefix
{
  # This function wraps a line of text for nice output.
  #
  # PARAMETERS:
  #   ${1}  - format_line_prefix  - The prefix to add to the first line.
  #   ${2}  - format_line_text    - The line to format
  #   ${3}  - format_indent_text  - Prefix text to put in front of wrapped lines
  #   ${4}  - formatted_line_var  - The variable to return the formatted text

  format_line_prefix="${1}"
  format_line_text="${2}"
  format_indent_text="${3}"
  formatted_line_var="${4}"

  formatted_output_line=""
  max_line_width="$(tput cols)"
  extra_line_text_len=${#format_line_prefix}

  if [ ${max_line_width} -gt ${#format_indent_text} ]; then
    while [ $((${max_line_width} - ${extra_line_text_len})) -lt ${#format_line_text} ]; do
      # Search backwards for whitespace to break on.
      last_pos=$((${max_line_width} - 1 - ${extra_line_text_len}))
      while [ ${last_pos} -ge 0 ]; do
        if [ "${format_line_text:${last_pos}:1}" = " " ]; then
          break
        fi
        if [ "${format_line_text:${last_pos}:${#return_line}}" = "${return_line}" ]; then
          break
        fi
        last_pos=$((${last_pos} - 1))
      done
      # if no whitespace found, try to break on / instead
      if [ ${last_pos} -lt 0 ]; then
        last_pos=$((${max_line_width} - 1 - ${extra_line_text_len}))
        while [ ${last_pos} -ge 0 ]; do
          if [ "${format_line_text:${last_pos}:1}" = "/" ]; then
            break
          fi
          last_pos=$((${last_pos} - 1))
        done
      fi

      # We're at the first whitespace location.  Now go back to the fist non-whitespace
      # character which is where we will actually break...
      while [ ${last_pos} -ge 0 ]; do
        if [ "${format_line_text:${last_pos}:1}" != " " ]; then
          if [ "${format_line_text:${last_pos}:${#return_line}}" != "${return_line}" ]; then
            break
          fi
        fi
        last_pos=$((${last_pos} - 1))
      done
      # Go forward one character to the whitespace character
      last_pos=$((${last_pos} + 1))

      # if we cannot break on whitespace, go to the last character and just break mid-line.
      if [ ${last_pos} -le 0 ]; then
        last_pos=$((${max_line_width} - 1 - ${extra_line_text_len}))
      fi

      # Split the line with a return...
      if [ ${last_pos} -gt 0 ]; then
        if [ -z "${formatted_output_line}" ]; then
          formatted_output_line="${format_line_prefix}"
        else
          formatted_output_line="${formatted_output_line}${return_line}${format_indent_text}"
        fi
        formatted_output_line="${formatted_output_line}${format_line_text:0:${last_pos}}"
      fi

      # Since we've split the line, strip out the whitespace where we split...
      while [ ${last_pos} -lt ${#format_line_text} ]; do
        if [ "${format_line_text:${last_pos}:1}" != " " ]; then
          if [ "${format_line_text:${last_pos}:${#return_line}}" != "${return_line}" ]; then
            break
          else
            # if after the newline is 2 or more spaces, just break here and assume that the
            # text is pre-formatted for output...
            if [ $((${last_pos} + ${#format_indent_text})) -lt ${#format_line_text} ]; then
              if [ "${format_line_text:${last_pos} + 1:${#format_indent_text}}" = "${format_indent_text}" ]; then
                last_pos=$((${last_pos} + ${#format_indent_text} + 1))
                break
              fi
            fi
          fi
        fi
        last_pos=$((${last_pos} + 1))
      done

      # Now we've split and stripped, format the rest of the line...
      if [ ${last_pos} -lt ${#format_line_text} ]; then
        format_line_text="${format_line_text:${last_pos}}"
      else
        format_line_text=""
      fi

      extra_line_text_len=${#format_indent_text}
    done

    # If there is any more text left over, add it to the last line.
    if [ ! -z "${format_line_text}" ]; then
      if [ -z "${formatted_output_line}" ]; then
        formatted_output_line="${format_line_prefix}"
      else
        formatted_output_line="${formatted_output_line}${return_line}${format_indent_text}"
      fi
      formatted_output_line="${formatted_output_line}${format_line_text}"
    fi
  else
    formatted_output_line="${format_line_text}"
  fi

  set_param_value "${formatted_line_var}" "${formatted_output_line}"
}

function format_line_for_menu
{
  # This function is a simplistic funtion for formatting a menu item selection
  #
  # PARAMETERS:
  #   ${1}  - menu_format_line_number   - The number of the line.
  #   ${2}  - menu_drop_line_number     - The number of the line.
  #   ${3}  - menu_format_line_text     - The line of text to be formatted.
  #   ${4}  - menu_format_line_out_var  - The return variable for the formatted line.

  menu_format_line_number="${1}"
  menu_drop_line_number="${2}"
  menu_format_line_text="${3}"
  menu_format_line_out_var="${4}"

  if [ ! -z "${menu_drop_line_number}" ]; then
    if [ ${menu_drop_line_number} -le ${menu_format_line_number} ]; then
      menu_format_line_number=$((${menu_format_line_number} - 1))
    fi
  fi

  formatted_line_output="  "
  if [ "${menu_format_line_number}" -lt 10 ]; then
    formatted_line_output="   "
  fi
  if [ "${menu_format_line_number}" -ge 100 ]; then
    formatted_line_output=" "
  fi
  # (
  format_line_with_prefix "${formatted_line_output}${menu_format_line_number}) " "${menu_format_line_text}" "      " formatted_line_output

  set_param_value "${menu_format_line_out_var}" "${formatted_line_output}"
}

function present_menu
{
  # As this "little" macro expands, it is becoming more and more menu driven,
  # so it is time to expand it to have a more generic menuing system.
  #
  # This funciton presents a menu to a user from an array of strings.
  #
  # PARAMETERS:
  #   ${1}  - menu_option_list        - The list of strings to be presented to the user.
  #   ${2}  - one_based               - If true, the first item in the menu is 1, otherwise 0.
  #   ${3}  - default_value           - The value to be defaulted if the user doesn't enter one.
  #   ${4}  - menu_prefix_text        - The text to place at the top of the menu.
  #   ${5}  - menu_prompt_text        - The text to use to prompt the user.
  #   ${6}  - menu_selection_var      - The variable to return the selected value.
  #                                     The returned value is a 0 based index into the string array
  #   ${7}  - menu_pre_formatted      - True if the menu is pre-formatted.
  #   ${8}  - pre_formatted_max_items - If the menu is pre-formatted, the value to pass to validate_prompt_value

  menu_option_list=("${!1}")
  one_based="${2}"
  default_value="${3}"
  menu_prefix_text="${4}"
  menu_prompt_text="${5}"
  menu_selection_var="${6}"
  menu_pre_formatted="${7}"
  pre_formatted_max_items="${8}"

  declare -a display_menu_items
  declare -a menu_item_heights
  declare -a menu_pagination_indexes
  declare -a menu_pagination_heights

  max_page_height="$(tput lines)"

  default_value_line=""
  default_value_index=""
  if [ "${menu_pre_formatted}" = "false" ]; then
    if [ ! -z "${default_value}" ]; then
      if echo "${default_value}" | grep -q "^[0-9]\+$"; then
        default_value_index="${default_value}"
        if [ "${one_based}" = "true" ]; then
          default_value_index=$((${default_value_index} - 1))
        fi
        if [ ${default_value_index} -ge 0 -a ${default_value_index} -lt ${#menu_option_list[@]} ]; then
          default_value_line="${menu_option_list[${default_value_index}]}"
        else
          default_value_index=""
        fi
      fi
    fi
  fi

  # Create a previous and Next menu selection for pagination
  format_line_with_prefix "P) " "<Previous page of menu selections>" "   " previous_menu_item
  height_text="$(echo "${previous_menu_item}" | wc -l)"
  get_line_number "${height_text}" "false" previous_height
  format_line_with_prefix "N) " "<Next page of menu selections>" "   " next_menu_item
  height_text="$(echo "${next_menu_item}" | wc -l)"
  get_line_number "${height_text}" "false" next_height

  # Build the menu structure and figure out line heights for pagination
  if [ ! -z "${menu_prefix_text}" ]; then
    format_line "${menu_prefix_text}" "" menu_prefix_text
    height_text="$(echo "${menu_prefix_text}" | wc -l)"
    get_line_number "${height_text}" "false" prefix_height
  else
    prefix_height=0
  fi
  if [ ! -z "${menu_prompt_text}" ]; then
    format_line "${menu_prompt_text}" "" menu_prompt_text
    height_text="$(echo "${menu_prompt_text}" | wc -l)"
    get_line_number "${height_text}" "false" prompt_height
  else
    prompt_height=0
  fi

  menu_option_index=0
  menu_select_index=0
  if [ "${one_based}" = "true" ]; then
    menu_select_index=$((${menu_select_index} + 1))
  fi

  menu_pagination_indexes[${#menu_pagination_indexes[@]}]=0
  page_menu_height=$((${prefix_height} + ${prompt_height}))
  current_page_number=0
  blank_lines_count=0
  default_menu_found_index=""
  default_menu_select_index=""
  while [ ${menu_option_index} -lt ${#menu_option_list[@]} ]; do
    if [ -z "${default_menu_found_index}" ]; then
      if [ ! -z "${default_value_index}" ]; then
        if [ ${default_value_index} -ne ${menu_option_index} ]; then
          if [ "${default_value_line}" = "${menu_option_list[${menu_option_index}]}" ]; then
            default_menu_found_index="${menu_option_index}"
            default_menu_select_index="$((${menu_option_index} - ${blank_lines_count}))"
          fi
        fi
      fi
    fi

    menu_display_line="true"
    if [ ! -z "${default_menu_found_index}" ]; then
      if [ ${default_menu_found_index} -eq ${menu_option_index} ]; then
        menu_display_line="false"
      fi
    fi
    if [ "${menu_display_line}" = "false" ]; then
      height_of_menu_item="0"
      menu_item_heights[${menu_option_index}]="${height_of_menu_item}"
      display_menu_items[${menu_option_index}]=""
    else
      if [ ${menu_option_index} -le ${#display_menu_items[@]} ]; then
        if [ "${menu_pre_formatted}" = "true" ]; then
          format_line "${menu_option_list[${menu_option_index}]}" "" menu_output_line
        else
          if [ -z "${menu_option_list[${menu_option_index}]}" ]; then
            menu_output_line=""
            blank_lines_count=$((${blank_lines_count} + 1))
          else
            format_line_for_menu "$((${menu_select_index} - ${blank_lines_count}))" "${default_menu_select_index}" "${menu_option_list[${menu_option_index}]}" menu_output_line
          fi
        fi

        height_text="$(echo "${menu_output_line}" | wc -l)"
        get_line_number "${height_text}" "false" height_of_menu_item
        display_menu_items[${menu_option_index}]="${menu_output_line}"
        menu_item_heights[${menu_option_index}]="${height_of_menu_item}"
      else
        menu_output_line="${display_menu_items[${menu_option_index}]}"
        height_of_menu_item="${menu_item_heights[${menu_option_index}]}"
      fi
    fi

    page_menu_height=$((${page_menu_height} + ${height_of_menu_item}))

    # If the current page becomes taller than the screen, backup and paginate...
    if [ ! -z "${menu_prompt_text}" -a ${page_menu_height} -ge ${max_page_height} ]; then
      # Add the previous and next menus so we account for them when we paginate...
      page_menu_height=$((${page_menu_height} + ${next_height}))

      # There must be at least one item per page...
      min_paginate_index=$((${menu_pagination_indexes[${current_page_number}]} + 1))
      while [ ${menu_option_index} -gt ${min_paginate_index} -a ${page_menu_height} -ge ${max_page_height} ]; do
        page_menu_height=$((${page_menu_height} - ${menu_item_heights[${menu_option_index}]}))
        if [ -z "${menu_option_list[${menu_option_index}]}" ]; then
          blank_lines_count=$((${blank_lines_count} - 1))
        fi
        menu_select_index=$((${menu_select_index} - 1))
        menu_option_index=$((${menu_option_index} - 1))
      done

      menu_pagination_heights[${current_page_number}]=${page_menu_height}
      current_page_number=$((${current_page_number} + 1))
      menu_pagination_indexes[${current_page_number}]=$((${menu_option_index} + 1))
      page_menu_height=$((${prefix_height} + ${prompt_height} + ${previous_height}))
    fi

    menu_option_index=$((${menu_option_index} + 1))
    menu_select_index=$((${menu_select_index} + 1))
  done
  menu_pagination_heights[${current_page_number}]=${page_menu_height}
  current_page_number=$((${current_page_number} + 1))
  menu_pagination_indexes[${current_page_number}]=$((${menu_option_index} + 1))
  menu_select_index=$((${menu_select_index} - 1 - ${blank_lines_count}))

  menu_return_value=""
  current_page_number=0
  while [ -z "${menu_return_value}" ]; do
    # if paginating, every page should fill the screen.
    if [ ${#menu_pagination_indexes[@]} -gt 2 ]; then
      blank_line_index=${menu_pagination_heights[${current_page_number}]}
      while [ ${blank_line_index} -lt ${max_page_height} ]; do
        echo ""
        blank_line_index=$((${blank_line_index} + 1))
      done
    fi
    if [ ! -z "${menu_prefix_text}" ]; then
      echo "${menu_prefix_text}"
    fi
    if [ ${current_page_number} -gt 0 ]; then
      echo "${previous_menu_item}"
    fi

    menu_option_index=${menu_pagination_indexes[${current_page_number}]}
    while [ ${menu_option_index} -lt ${#display_menu_items[@]} -a ${menu_option_index} -lt ${menu_pagination_indexes[$((${current_page_number} + 1))]} ]; do
      menu_display_line="true"
      if [ ! -z "${default_menu_select_index}" ]; then
        if [ ${default_menu_found_index} -eq ${menu_option_index} ]; then
          menu_display_line="false"
        fi
      fi
      if [ "${menu_display_line}" = "true" ]; then
        echo "${display_menu_items[${menu_option_index}]}"
      fi

      menu_option_index=$((${menu_option_index} + 1))
    done
    if [ ${current_page_number} -lt $((${#menu_pagination_indexes[@]} - 2)) ]; then
      echo "${next_menu_item}"
    fi

    if [ -z "${menu_prompt_text}" ]; then
      menu_return_value="0"
    else
      read -p "${menu_prompt_text}" menu_sel_index
      if [ "${menu_pre_formatted}" = "true" ]; then
        menu_select_index="${pre_formatted_max_items}"
      fi
      validate_selection="true"
      if [ ${#menu_pagination_indexes[@]} -gt 2 ]; then
        if [ "${menu_sel_index}" = "p" ]; then
          validate_selection="false"
          if [ ${current_page_number} -gt 0 ]; then
            current_page_number=$((${current_page_number} - 1))
          fi
        else
          if [ "${menu_sel_index}" = "P" ]; then
            validate_selection="false"
            if [ ${current_page_number} -gt 0 ]; then
              current_page_number=$((${current_page_number} - 1))
            fi
          fi
        fi
        if [ "${menu_sel_index}" = "n" ]; then
          validate_selection="false"
          if [ ${current_page_number} -lt $((${#menu_pagination_indexes[@]} - 2)) ]; then
            current_page_number=$((${current_page_number} + 1))
          fi
        else
          if [ "${menu_sel_index}" = "N" ]; then
            validate_selection="false"
            if [ ${current_page_number} -lt $((${#menu_pagination_indexes[@]} - 2)) ]; then
              current_page_number=$((${current_page_number} + 1))
            fi
          fi
        fi
      fi

      if [ "${validate_selection}" = "true" ]; then
        validate_prompt_value "${menu_select_index}" "${default_menu_select_index}" "${one_based}" "${default_value}" "${menu_sel_index}" menu_return_value
        if [ ${#menu_pagination_indexes[@]} -gt 2 ]; then
          if [ -z "${menu_return_value}" ]; then
            read -n1 -p "<Press any key to continue>" wait_prompt_value
          fi
        fi
      else
        menu_return_value=""
      fi
    fi
  done

  set_param_value "${menu_selection_var}" "${menu_return_value}"
}

function clean_history
{
  # This function cleans out the history on a regular basis...
  # Right now, I let the file grow to 15,000 lines then
  # truncate it to the latest 10,000 lines.
  # This should be both not too large, but sufficient history.
  # If I need a more comprehensive history, I'll take care of that
  # later.

  mkdir -p ${build_log_directory}
  if [ -f ${build_log_directory}/recorded_history.txt ]; then
    line_count="$(wc -l ${build_log_directory}/recorded_history.txt)"
    get_line_number "${line_count}" "false" line_count

    if [ ${line_count} -gt 15000 ]; then
      replace_lines="$(tail -n10000 ${build_log_directory}/recorded_history.txt)"
      echo "${replace_lines}" > ${build_log_directory}/recorded_history.txt
    fi
  fi
}

function record_history
{
  # This function records a history of commands run with this script.
  # (For debugging purposes.)
  #
  # PARAMETERS:
  #   ${1}  - record_string

  clean_history

  record_string="${1}"

  mkdir -p ${build_log_directory}
  echo "$(date ${time_format_sting}): ${record_string}" >> ${build_log_directory}/recorded_history.txt
}

function record_branch
{
  # This function records the current branch name in the history.
  # This function also returns that branch name.
  #
  # PARAMETERS
  #   ${1}  - record_name_val - The variable to return the branch name in

  record_name_val="${1}"

  record_dir="$(pwd)"
  cd ${build_base_directory}
  record_branch_list="$(git branch)"
  cur_branch_name=""
  while read read_record_branch_name; do
    # Remove the * for the current branch, and save the current branch index.
    if [ "${read_record_branch_name:0:1}" = "*" ]; then
      read_record_branch_name=${read_record_branch_name:2}
      record_history "  # Current Branch: ${read_record_branch_name}"
      cur_branch_name="${read_record_branch_name}"
      break
    fi
  done <<< "${record_branch_list}"
  cd ${record_dir}

  set_param_value "${record_name_val}" "${cur_branch_name}"
}

function find_version
{
  # This script was designed to run outside of the project
  # directory.  But it is now being checked into project so
  # we need to adjust it to work in the project folder.
  #
  # To that end, I am having the system copy it up one level
  # but if I do that, it needs to update itself appropriately.
  #
  # This function gets the version number of this file so it can
  # be determined which is to be used.
  #
  # PARAMETERS:
  #   ${1}  - versioned_file  - The path to the file to find the
  #                             version in.
  #   ${2}  - return_version  - The variable to return the version in.

  versioned_file="${1}"
  return_version="${2}"

  version_line=""
  set +e
  version_line="$(grep "^# version=" ${versioned_file} 2>&1)"
  set -e
  if [ "${version_line:0:10}" = "# version=" ]; then
    version_line="${version_line:10}"
  else
    version_line=""
  fi

  set_param_value "${return_version}" "${version_line}"
}

function record_version
{
  record_version_dir="$(pwd)"
  cd ${current_directory}
  find_version "${1}" current_file_version
  record_history "  # build_project version = \"${current_file_version}\""
  cd ${record_version_dir}
}

function update_build_project
{
  # This function compares the version number of the two build filse
  # (the current one, and the one in the project folder - checked in)
  # and copies the one from the project folder if it is more recent.

  declare -a split_core
  declare -a split_current

  mkdir -p ${build_log_directory}/script_backups

  find_version "${build_base_directory}/build_project" core_file_version
  find_version "${build_parent_directory}/build_project" current_file_version

  # split the version by .
  orig_ifs="${IFS}"
  IFS="."
  split_core=(${core_file_version})
  split_current=(${current_file_version})
  IFS="${orig_ifs}"

  # Compare the version number from most significant numbe
  # to least.
  version_index=0
  version_comparison="equal to"
  while [ "${version_index}" -lt ${#split_core[@]} ]; do
    if [ "${version_index}" -lt ${#split_current[@]} ]; then
      if [ "${version_comparison}" = "equal to" ]; then
        if [ "${split_core[${version_index}]}" -lt "${split_current[${version_index}]}" ]; then
          version_comparison="less than"
        fi
        if [ "${split_core[${version_index}]}" -gt "${split_current[${version_index}]}" ]; then
          version_comparison="greater than"
        fi
      fi
    fi
    version_index=$((${version_index} + 1))
  done
  if [ "${version_comparison}" = "equal to" ]; then
    # If they are the same up to the values they share in common
    # The one that has more sub-numbers is the greater value.
    # (i.e. 1.1.1.1 > 1.1.1)
    if [ "${#split_core[@]}" -lt "${#split_current[@]}" ]; then
      version_comparison="less than"
    fi
    if [ "${#split_core[@]}" -gt "${#split_current[@]}" ]; then
      version_comparison="greater than"
    fi
  fi

  if [ -z "${current_file_version}" ]; then
    current_file_version="0"
  fi
  if [ "${version_comparison}" = "greater than" ]; then
    echo ""
    echo "The checked in version (${core_file_version}) is ${version_comparison} the current version (${current_file_version})."
    echo ""

    if [ -f ${build_log_directory}/script_backups/${current_file_version}.build_project ]; then
      if ! diff -q ${build_log_directory}/script_backups/${current_file_version}.build_project ${build_parent_directory}/build_project; then
        mv ${build_log_directory}/script_backups/${current_file_version}.build_project ${build_log_directory}/script_backups/${current_file_version}.build_project.$(date ${time_format_sting})
      fi
    fi

    if [ -f "${build_parent_directory}/build_project" ]; then
      mv ${build_parent_directory}/build_project ${build_log_directory}/script_backups/${current_file_version}.build_project
    fi

    cp ${build_base_directory}/build_project ${build_parent_directory}/build_project
    chmod +x ${build_base_directory}/build_project
    chmod +x ${build_parent_directory}/build_project
  fi
}

function validate_prompt_value
{
  # This function validates the typed in value to a list prompt.
  #
  # PARAMETERS:
  #   ${1}  - max_value                 - The max value the user can enter
  #   ${2}  - validate_drop_line_number - The number of the line.
  #   ${3}  - one_based                 - True if the user can type >= 0 else >= 1
  #                                       If true, max_value is decremented by 1
  #   ${4}  - default_value             - The value to return if the user entered ""
  #   ${5}  - user_entry                - The value the user entered
  #   ${6}  - return_prompt_selection   - The value selected
  #                                       Could be:
  #                                         0 -> max_vlaue
  #                                         default_value
  #                                         "" (invalid entry)

  max_value="${1}"
  validate_drop_line_number="${2}"
  one_based="${3}"
  default_value="${4}"
  user_entry="${5}"
  return_prompt_selection="${6}"
  prompt_value_selected=""

  if [ -z "${user_entry}" ]; then
    prompt_value_selected="${default_value}"
  else
    if echo "${user_entry}" | grep -q "[^0-9]"; then
      prompt_value_selected=""
      echo ""
      echo "Improperly formatted input."
      echo ""
    else
      if [ "${one_based}" = "true" ]; then
        user_entry=$((${user_entry} - 1))
        max_value=$((${max_value} - 1))
      fi
      if [ ! -z "${validate_drop_line_number}" ]; then
        if [ ${validate_drop_line_number} -le ${user_entry} ]; then
          user_entry=$((${user_entry} + 1))
        fi
      fi

      if [ ${user_entry} -lt 0 -o ${user_entry} -gt ${max_value} ]; then
        echo ""
        echo "Value out of range."
        echo ""

        prompt_value_selected=""
      else
        prompt_value_selected="${user_entry}"
      fi
    fi
  fi

  set_param_value "${return_prompt_selection}" "${prompt_value_selected}"
}

function prompt_commands_or_help
{
  # This function builds the help string or a selection prompt.
  #   NOTE: These should really be sepearte functions, but about
  #         90% of the code for these is shared, and I don't want
  #         to copy/paste all of it, so I'm being lazy and doing
  #         it as one function anyway.
  #
  #         In a more robust language, I would create another
  #         function for the shared work.
  #
  # Parameters:
  #  ${1} - show_help         - If set to true, shows the help options...
  #  ${2} - prompt_select_var - The variable into which to put the
  #                             option selected by the user.

  declare -a help_menu_lines

  show_help="${1}"
  prompt_select_var="${2}"
  selected_val=""
  declare -a help_prefixes
  declare -a short_help_prefixes
  spaces_constant="                                                                      "
  build_string=""
  build_index=0
  max_len=0
  max_single_len=0
  max_help_width="$(tput cols)"
  max_help_width=$((${max_help_width} / 3))

  # build a list of the options.
  # Since there can be multiple command line options for each itm
  # We build the list of options first, then append the descriptions...
  while [ "${build_index}" -lt "${#command_options_show[@]}" ]; do
    option_list=(${command_options_show[${build_index}]})

    # Build a comma list of the options.
    option_index=0
    build_string=""
    while [ "${option_index}" -lt "${#option_list[@]}" ]; do
      if [ ! -z "${build_string}" ]; then
        build_string="${build_string}, "
      fi
      build_string="${build_string}${option_list[${option_index}]}"

      if [ ${#option_list[${option_index}]} -gt ${max_single_len} ]; then
        max_single_len=${#option_list[${option_index}]}
      fi

      option_index=$((${option_index} + 1))
    done
    # Find the max length so we can align the descriptions later.
    if [ "${max_len}" -lt "${#build_string}" ]; then
      max_len=${#build_string}
    fi
    build_string="${build_string}${spaces_constant}"
    help_prefixes[${build_index}]="${build_string}"
    short_help_prefixes[${build_index}]="${option_list[0]}${spaces_constant}"

    build_index=$((${build_index} + 1))
  done
  max_len=$((${max_len} + 1))
  max_single_len=$((${max_single_len} + 1))

  if [ "${show_help}" = "true" ]; then
    help_pre_text="Usage: build_project [<OPTION> ...]${return_line}${return_line}OPTION:"
    help_prompt_text=""
  else
    help_pre_text="Please select the command to run:"
    help_prompt_text="Type in the value of the command that you want to execute: "
  fi

  build_index=0
  while [ "${build_index}" -lt "${#command_options_show[@]}" ]; do
    if [ ${max_help_width} -lt ${max_len} ]; then
      temp_line="      ${short_help_prefixes[${build_index}]:0:${max_single_len}}- ${command_descriptions[${build_index}]}"
      format_line "${temp_line}" "${spaces_constant:0:${max_single_len} + 6 + 2}" final_line
    else
      temp_line="      ${help_prefixes[${build_index}]:0:${max_len}}- ${command_descriptions[${build_index}]}"
      format_line "${temp_line}" "${spaces_constant:0:${max_len} + 6 + 2}" final_line
    fi

    if [ ${max_help_width} -lt ${max_len} ]; then
      option_list=(${command_options_show[${build_index}]})
      if [ ${#option_list[@]} -gt 0 ]; then
        option_index=1
        split_line_on_char "${final_line}" "${return_line}" add_line split_line
        final_line="${add_line}"
        while [ ! -z "${split_line}" ]; do
          split_line_on_char "${split_line}" "${return_line}" add_line split_line
          if [ ${option_index} -lt ${#option_list[@]} ]; then
            add_line="      ${option_list[${option_index}]:0:${max_single_len}}${add_line:${max_single_len} + 6 - 1}}"
            option_index=$((${option_index} + 1))
          fi
          final_line="${final_line}${return_line}${add_line}"
        done
        while [ ${option_index} -lt ${#option_list[@]} ]; do
          add_line="      ${option_list[${option_index}]:0:${max_single_len}}"
          option_index=$((${option_index} + 1))
          final_line="${final_line}${return_line}${add_line}"
        done
      fi
    fi

    help_menu_lines[${#help_menu_lines[@]}]="${final_line:6}"
    build_index=$((${build_index} + 1))
  done

  # If we are prompting for input, we repeat while the input is still not valid....
  while [ "${selected_val}" = "" ]; do
    present_menu help_menu_lines[@] "true" "" "${help_pre_text}" "${help_prompt_text}" validated_prompt_index "false" "0"

    if [ "${show_help}" = "true" ]; then
      format_line "If no options are set, then the system will present you with a menu of options." "" help_command_info
      echo "${return_line}${help_command_info}"
      selected_val="help"
    else
      # If we are prompting, read the input and validate.
      option_list=(${command_options_show[${validated_prompt_index}]})
      variables_list=(${command_vars[${validated_prompt_index}]})
      selected_val="${option_list[0]}"

      # This is a hack.
      # I don't know how (and I'm too lazy to look up) to return an array
      # in a varaible.
      # so I use a global variable as the return value.
      unset additional_params
      if [ ${#variables_list[@]} -gt 1 ]; then
        # prompt user for additional inputs....
        prompt_user_input_index=1
        while [ ${prompt_user_input_index} -lt ${#variables_list[@]} ]; do
          user_input_value=""
          format_line "The command ${option_list[0]} reqires additional input values.${return_line}Please specfy the value for ${variables_list[${prompt_user_input_index}]}: " "" prompt_command_value_text
          while [ -z "${user_input_value}" ]; do
            read -p "${prompt_command_value_text}" user_input_value

            if [ -z "${user_input_value}" ]; then
              echo ""
              echo "You must specify a value."
            else
              additional_params[$((${prompt_user_input_index} - 1))]="${user_input_value}"
            fi
          done
          prompt_user_input_index=$((${prompt_user_input_index} + 1))
        done
      fi
    fi
  done

  if [ "${show_help}" != "true" ]; then
    set_param_value "${prompt_select_var}" "${selected_val}"
  fi
}

function unset_all_arguments
{
  # This function resets the value of the variables that are used to
  # indicate which parameters were set to the value "unset"

  build_index=0
  while [ "${build_index}" -lt "${#command_options[@]}" ]; do
    cmd_values=(${command_vars[${build_index}]})
    eval "${cmd_values[0]}=\"unset\""
    cmd_index=1
    while [ "${cmd_index}" -lt "${#cmd_values[@]}" ]; do
      eval "${cmd_values[${cmd_index}]}=\"\""
      cmd_index=$((${cmd_index} + 1))
    done

    build_index=$((${build_index} + 1))
  done
}

function get_command_configs
{
  # PARAMETERS:
  #   ${1}  - get_command_args
  #   ${2}  - current_position
  #   ${3}  - command_index
  #   ${4}  - final_position

  declare -a get_command_args=("${!1}")
  current_position="${2}"
  command_index="${3}"
  final_position="${4}"

  cmd_values=(${command_vars[${command_index}]})
  eval "${cmd_values[0]}=\"true\""

  cmd_index=1
  while [ "${cmd_index}" -lt "${#cmd_values[@]}" ]; do
    current_position=$((${current_position} + 1))
    if [ "${current_position}" -ge "${#get_command_args[@]}" ]; then
      echo "There was a missing parameter for the command: ${command_options[${command_index}]}"
      exit 1
    fi

    eval "${cmd_values[${cmd_index}]}='${get_command_args[${current_position}]}'"
    record_history "    \"${get_command_args[${current_position}]}\""
    cmd_index=$((${cmd_index} + 1))
  done

  set_param_value "${final_position}" "${current_position}"
}

function set_default_param_values
{
  # This function sets the default values for a parameter if it isn't specified by the user
  # Currently, there is only one parameter whose value we default, but we put it into a function
  # to organize it, and in case we want to have more in the future.

  # Check to see if a -p option has been set...
  smoke_browser_set="false"
  if [ ! -z "${user_smoke_params}" ]; then
    if echo "${user_smoke_params}" | grep -q -e "-p[[:space:]][[:space:]]*[a-z0-9][a-z0-9]*"; then
      smoke_browser_set="true"
    fi
  fi
}

function process_command_lines
{
  initialize_commands

  # This function parses the array of command line arguments
  # and sets the global variables appropriately based on the
  # passed in commands.
  #
  # PARAMETERS:
  #   ${1}  - command_args  - The array of command line arguments

  declare -a command_args=("${!1}")
  declare -a single_commands
  declare -a single_command_indexes
  declare -a double_commands
  declare -a double_command_indexes

  # Check that the arrays with the options are setup properly.
  if [ "${#command_descriptions[@]}" != "${#command_options[@]}" ]; then
    echo "The command options are not setup properly.  Aborting."
    exit 2
  else
    if [ "${#command_descriptions[@]}" != "${#command_vars[@]}" ]; then
      echo "The command options are not setup properly.  Aborting."
      exit 2
    fi
  fi

  # Pull out all of the options to look for into individual arrays for use in this function.
  build_index=0
  while [ "${build_index}" -lt "${#command_options[@]}" ]; do
    option_list=(${command_options[${build_index}]})

    option_index=0
    while [ "${option_index}" -lt "${#option_list[@]}" ]; do
      if [ "${option_list[${option_index}]:0:2}" = "--" ]; then
        double_commands[${#double_commands[@]}]="${option_list[${option_index}]:2}"
        double_command_indexes[${#double_command_indexes[@]}]="${build_index}"
      else
        single_commands[${#single_commands[@]}]="${option_list[${option_index}]:1}"
        single_command_indexes[${#single_command_indexes[@]}]="${build_index}"
      fi

      option_index=$((${option_index} + 1))
    done

    build_index=$((${build_index} + 1))
  done

  do_second_loop="false"

  # process the passed in parameters...
  while [ "${param_set}" != "true" -o "${do_second_loop}" = "true" ]; do
    record_history "Command Parameters:"
    unset_all_arguments

    invalid_param="false"
    param_set="false"
    argument_pos=0
    while [ "${argument_pos}" -lt "${#command_args[@]}" ]; do
      argument_value="${command_args[${argument_pos}]}"
      record_history "  ${argument_value}"

      if [ "${#argument_value}" -ge "2" ]; then
        # check for -- arguments
        if [ "${argument_value:0:2}" = "--" ]; then
          # Find the argument...
          found_param="false"
          find_arg_index=0
          while [ "${find_arg_index}" -lt "${#double_commands[@]}" ]; do
            if [ "${argument_value:2}" = "${double_commands[${find_arg_index}]}" ]; then
              get_command_configs command_args[@] ${argument_pos} ${double_command_indexes[${find_arg_index}]} new_pos
              argument_pos="${new_pos}"

              param_set="true"
              found_param="true"
              break
            fi

            find_arg_index=$((${find_arg_index} + 1))
          done

          # If we couldn't find the argument, indicate that and fail...
          if [ "${found_param}" = "false" ]; then
            echo "Could not find the parameter \"${argument_value}\""
            invalid_param="true"
            break
          fi
        else
          # look for - arguments by reading each character in the string value individually
          if [ "${argument_value:0:1}" = "-" ]; then
            single_arg_index=1
            while [ "${single_arg_index}" -lt "${#argument_value}" ]; do
              # Look for the argument...
              found_param="false"
              find_arg_index=0
              while [ "${find_arg_index}" -lt "${#single_commands[@]}" ]; do
                if [ "${argument_value:${single_arg_index}:1}" = "${single_commands[${find_arg_index}]}" ]; then
                  get_command_configs command_args[@] ${argument_pos} ${single_command_indexes[${find_arg_index}]} new_pos

                  param_set="true"
                  found_param="true"
                  break
                fi

                find_arg_index=$((${find_arg_index} + 1))
              done

              # If we couldn't find the argument, indicate that and fail...
              if [ "${found_param}" = "false" ]; then
                echo "Could not find the parameter \"${argument_value:${single_arg_index}:1}\" in the argument \"${argument_value}\""
                invalid_param="true"
                break
              fi

              single_arg_index=$((${single_arg_index} + 1))
            done
          else
            # if it isn't a - or --, then it is a failure...
            echo "Could not find the parameter \"${argument_value}\""
            invalid_param="true"
            break
          fi
        fi
      else
        # if the argument is only 1 character, it is a failure...
        echo "Could not find the parameter \"${argument_value}\""
        invalid_param="true"
        break
      fi

      argument_pos=$((${argument_pos} + 1))
    done

    # If there are any invalid parameters, ignore everything, reset and prompt
    if [ "${invalid_param}" = "true" ]; then
      unset_all_arguments
      param_set="false"
    fi

    # If there are no arguments, prompt the use for what to do.
    if [ "${param_set}" = "false" -o "${do_second_loop}" = "true" ]; then
      param_set="false"
      if [ "${do_second_loop}" = "false" ]; then
        unset command_args
      fi
      do_second_loop="false"

      prompt_commands_or_help "false" prompt_command

      command_args[${#command_args[@]}]="${prompt_command}"

      # This is a hack.
      # If the command requires additional parameters, then
      # add them to the command here, and loop again...
      if [ ${#additional_params[@]} -gt 0 ]; then
        do_second_loop="true"
        addtl_index=0
        while [ ${addtl_index} -lt ${#additional_params[@]} ]; do
          command_args[${#command_args[@]}]="${additional_params[${addtl_index}]}"
          addtl_index=$((${addtl_index} + 1))
        done
        unset additional_params
      fi
    fi
  done
}

function is_using_ubuntu
{
  # This function "returns" whether or not the OS is Ubuntu
  #
  # PARAMETERS:
  #   ${1}  - ubuntu_return_var - The return variable for the return value

  ubuntu_return_var="${1}"

  is_using="false"
  if [ -f /etc/issue ]; then
    if grep -qi "Ubuntu" /etc/issue; then
      is_using="true"
    fi
  fi

  set_param_value "${ubuntu_return_var}" "${is_using}"
}

function clear_old_outputs
{
  # This function clears out old backups of output files.
  #
  # PARAMETERS:
  #   ${1}  - file_directory  - The directory where the output files are located.
  #   ${2}  - file_prefix     - The name of the file whose backups are to be deleted.
  #   ${3}  - file_age        - The length of time to keep the backup files.
  #                             If not specified, the default is 1 week. (1w)
  #   ${4}  - alt_file_age    - file_age for ubuntu...

  file_directory="${1}"
  file_prefix="${2}"
  file_age="${3}"
  alt_file_age="${4}"

  mkdir -p ${file_directory}/old

  if [ -z "${file_age}" ]; then
    file_age="1w"
  fi
  if [ -z "${alt_file_age}" ]; then
    altfile_age="7 days"
  fi

  # Delete old files that are beyond the age threshold.
  is_using_ubuntu using_ubuntu

  if [ "${using_ubuntu}" = "true" ]; then
    remove_min=${file_directory}/old/${file_prefix}.$(date -d "-${alt_file_age}" ${time_format_sting})
  else
    remove_min=${file_directory}/old/${file_prefix}.$(date -v "-${file_age}" ${time_format_sting})
  fi

  for remove_file in ${file_directory}/old/${file_prefix}.*; do
    if [ "${remove_file}" \< "${remove_min}" ]; then
      if [ -d ${remove_file} ]; then
        echo "Deleting old directory: ${remove_file}..."
        rm -rf ${remove_file}
      fi
      if [ -e ${remove_file} ]; then
        echo "Deleting old ouptut file: ${remove_file}..."
        rm ${remove_file}
      fi
    fi
  done
}

function backup_outputs
{
  # This funtion ensures that the output file specified does not exist.
  # If the file does exist, it will be backed up to a date stamped name.
  # Old backup files will be deleted after the specified amount of time.
  #
  # PARAMETERS:
  #   ${1}  - file_directory  - The directory where the output files are located.
  #   ${2}  - file_prefix     - The name of the file whose backups are to be deleted.
  #   ${3}  - file_age        - The length of time to keep the backup files.
  #                             If not specified, the default is 1 week. (1w)
  #   ${4}  - alt_file_age    - file_age for ubuntu...

  file_directory="${1}"
  file_prefix="${2}"
  file_age="${3}"
  alt_file_age="${4}"

  mkdir -p ${file_directory}

  if [ -e "${file_directory}/${file_prefix}" ]; then
    mv ${file_directory}/${file_prefix} ${file_directory}/old/${file_prefix}.$(date ${time_format_sting})
  fi

  clear_old_outputs "${file_directory}" "${file_prefix}" "${file_age}" "${alt_file_age}"
}

function extract_file_name
{
  # This function splits a filename into the directory and filename.
  #
  # PARAMETERS:
  #   ${1}  - extract_file_name_file
  #   ${2}  - extract_directory_var
  #   ${3}  - extract_file_var

  extract_file_name_file="${1}"
  extract_directory_var="${2}"
  extract_file_var="${3}"

  base_file_name="${extract_file_name_file}"
  base_dir_name=""
  if [ "${base_file_name:0:1}" = "/" ]; then
    base_dir_name="/"
  fi
  while [ ! -z "${extract_file_name_file}" ]; do
    split_line_on_char "${extract_file_name_file}" "/" sub_dir_name extract_file_name_file
    if [ -z "${extract_file_name_file}" ]; then
      base_file_name="${sub_dir_name}"
    else
      if [ ! -z "${base_dir_name}" -a "${base_dir_name:${#base_dir_name} - 1:1}" != "/" ]; then
        base_dir_name="${base_dir_name}/"
      fi
      base_dir_name="${base_dir_name}${sub_dir_name}"
    fi
  done

  set_param_value "${extract_directory_var}" "${base_dir_name}"
  set_param_value "${extract_file_var}" "${base_file_name}"
}

function has_file_changed
{
  # This function checks a file to see if it has changed, and returns wether or not it has.
  #
  # PARAMETERS:
  #   ${1}  - has_changed_file
  #   ${2}  - has_changed_return_var

  has_changed_file="${1}"
  has_changed_return_var="${2}"

  file_has_changed_val="true"

  extract_file_name "${has_changed_file}" changed_file_dir changed_file_name
  file_changed_rel_dir="${changed_file_dir}"
  if [ ${#file_changed_rel_dir} -ge ${#build_base_directory} ]; then
    if [ "${file_changed_rel_dir:0:${#build_base_directory}}" = "${build_base_directory}" ]; then
      file_changed_rel_dir="${file_changed_rel_dir:${#build_base_directory} + 1}"
    fi
  fi

  mkdir -p ${build_log_directory}/archive/${file_changed_rel_dir}

  if [ -f ${build_log_directory}/archive/${file_changed_rel_dir}/${changed_file_name} ]; then
    if diff -q ${has_changed_file} ${build_log_directory}/archive/${file_changed_rel_dir}/${changed_file_name}; then
      file_has_changed_val="false"
    fi
  fi

  set_param_value "${has_changed_return_var}" "${file_has_changed_val}"
}

function archive_file
{
  # This function checks a file to see if it has changed, and returns wether or not it has.
  #
  # PARAMETERS:
  #   ${1}  - file_to_archive

  file_to_archive="${1}"

  file_has_changed_val="true"

  extract_file_name "${file_to_archive}" changed_file_dir changed_file_name
  file_changed_rel_dir="${changed_file_dir}"
  if [ ${#file_changed_rel_dir} -ge ${#build_base_directory} ]; then
    if [ "${file_changed_rel_dir:0:${#build_base_directory}}" = "${build_base_directory}" ]; then
      file_changed_rel_dir="${file_changed_rel_dir:${#build_base_directory} + 1}"
    fi
  fi

  mkdir -p ${build_log_directory}/archive/${file_changed_rel_dir}
  cp ${file_to_archive} ${build_log_directory}/archive/${file_changed_rel_dir}/${changed_file_name}
}

function pull_project_source
{
  # This function pulls the project and returns if the pull updated any
  # files or not.
  #
  # PARAMETERS:
  #   ${1}  - return_var  - The variable name to return the result in.

  return_var="${1}"

  record_branch recorded_name
  backup_outputs "${build_log_directory}" "git_pull.txt" "1w" "7 days"

  cd ${build_base_directory}

  get_origin_branch "${recorded_name}" "pull" "true" remote_branch_name

  echo "${return_line}Pulling source..." 2>&1 | tee -a ${build_log_directory}/git_pull.txt
  execute_command "git pull origin ${remote_branch_name}" ${build_log_directory}/git_pull.txt pull_success pull_text
  update_origin_branch "${recorded_name}" "${remote_branch_name}"

  pull_has_updates="true"
  if [ "${pull_text}" = "Already up-to-date." ]; then
    pull_has_updates="false"
  fi

  set_param_value "${return_var}" "${pull_has_updates}"
}

function reset_databases
{
  # This funciton is mostly useless, but I may want it again.
  # so for now, I'm leaving it in...
  #
  # Parameters:
  #   ${1}  - build_environment - The rails environment to use.

  build_environment="${1}"
  trace_file="${build_log_directory}/db_reset.txt"

  record_history "  # Resetting databases"
  backup_outputs "${build_log_directory}" "db_reset.txt" "1w" "7 days"

  reset_database_directories=$(find . "db")
  while read reset_directory; do
    if [ -d ${reset_directory} ]; then
      cd reset_directory/..

      create_db_users "$(pwd)" "${build_environment}" "${trace_file}"

      echo "${return_line}Dropping the database..." 2>&1 | tee -a ${trace_file}
      if [ -f config/database.yml ]; then
        execute_command "RAILS_ENV=${build_environment} bundle exec rake db:drop" ${trace_file} "" ""
      fi
      if [ -f config/mongoid.yml ]; then
        execute_command "RAILS_ENV=${build_environment} bundle exec rake db:mongoid:drop" ${trace_file} "" ""
      fi
    fi
  done <<< "${reset_database_directories}"
}

function create_single_user
{
  # This function creates a single user from the passed in parameters.
  #
  # PARAMETERS
  #   ${1}  - param_adapter_val   - The adapter.  We only do something with mysql2
  #   ${2}  - param_database_val  - The database name.
  #   ${3}  - param_username_val  - The username.
  #   ${4}  - param_password_val  - The password.

  param_adapter_val="${1}"
  param_database_val="${2}"
  param_username_val="${3}"
  param_password_val="${4}"
  create_error_log_file="${5}"

  if [ "${param_adapter_val}" = "mysql2" ]; then
    set +e
    cur_user="$(mysql -u root -e "SELECT User FROM mysql.user WHERE mysql.user.User='${param_username_val}' AND mysql.user.Host='localhost'")"
    user_failure="${?}"
    set -e

    if [ "${user_failure}" != "0" -o -z "${cur_user}" ]; then
      echo "Creating the MySQL user in case it doesn't already exist..." 2>&1 | tee -a ${create_error_log_file}
      execute_command "mysql -u root -e \"CREATE USER '${param_username_val}'@'localhost' identified by '${param_password_val}';\"" ${create_error_log_file} create_user_success ""
    else
      echo "The MySQL user \"${param_username_val}\" already exists." 2>&1 | tee -a ${create_error_log_file}
    fi

    echo "Granting the user permissions..." 2>&1 | tee -a ${create_error_log_file}
    execute_command "mysql -u root -e \"GRANT ALL PRIVILEGES ON ${param_database_val}.* to '${param_username_val}'@'localhost';\"" "" ""
  fi
}

function extract_db_configurations
{
  # This function extracts the DB configuration information out into array values.
  #
  # PARAMETERS:
  #   ${1}  - extract_engine_path
  #   ${2}  - section_names_var
  #   ${3}  - adapters_var
  #   ${4}  - databases_var
  #   ${5}  - usernames_var
  #   ${6}  - passwords_var

  extract_engine_path="${1}"
  section_names_var="${2}"
  adapters_var="${3}"
  databases_var="${4}"
  usernames_var="${5}"
  passwords_var="${6}"

  extract_orig_ifs="${IFS}"
  IFS="##***&&&^^^&&&##"

  default_adapter=""
  extract_yml_file=""
  if [ -f ${extract_engine_path}/config/database.yml ]; then
    extract_yml_file="$(cat ${extract_engine_path}/config/database.yml)"
  fi
  if [ -f ${extract_engine_path}/config/mongoid.yml ]; then
    default_adapter="mongo"
    extract_yml_file="$(cat ${extract_engine_path}/config/mongoid.yml)"
  fi

  extract_adapter_val=""
  extract_database_val=""
  extract_username_val=""
  extract_password_val=""
  extract_section_name_val=""

  while read extract_config_line; do
    # ignore comment lines...
    if ! echo "${extract_config_line}" | grep -q "^[ ${tab_character}]*\#"; then
      if [ ! -z "${extract_config_line}" ]; then
        if echo "${extract_config_line}" | grep -q "^[^ ${tab_character}][^ ${tab_character}]*\:"; then
          if [ ! -z "${extract_section_name_val}" ]; then
            append_array_value "${section_names_var}" "${extract_section_name_val}"
            append_array_value "${databases_var}" "${extract_database_val}"
            append_array_value "${usernames_var}" "${extract_username_val}"
            append_array_value "${passwords_var}" "${extract_password_val}"
            if [ -z "${extract_adapter_val}" ]; then
              extract_adapter_val="${default_adapter}"
            fi
            append_array_value "${adapters_var}" "${extract_adapter_val}"
          fi

          split_line_on_char "${extract_config_line}" ":" extract_section_name_val extract_waste_val
          extract_adapter_val=""
          extract_database_val=""
          extract_username_val=""
          extract_password_val=""
        else
          # Minus a real string library, this is how I can do it quickly...
          extract_config_parse_start_index="0"
          while [ ${extract_config_parse_start_index} -lt ${#extract_config_line} ]; do
            if [ "${extract_config_line:${extract_config_parse_start_index}:1}" = "${tab_character}" ]; then # <tab>
              extract_config_parse_start_index=$((${extract_config_parse_start_index} + 1))
            else
              if [ "${extract_config_line:${extract_config_parse_start_index}:1}" = " " ]; then
                extract_config_parse_start_index=$((${extract_config_parse_start_index} + 1))
              else
                break
              fi
            fi
          done
          extract_config_parse_end_index="${extract_config_parse_start_index}"
          while [ ${extract_config_parse_end_index} -lt ${#extract_config_line} ]; do
            if [ "${extract_config_line:${extract_config_parse_end_index}:1}" != "${tab_character}" ]; then # <tab>
              if [ "${extract_config_line:${extract_config_parse_end_index}:1}" != " " ]; then
                if [ "${extract_config_line:${extract_config_parse_end_index}:1}" != ":" ]; then
                  extract_config_parse_end_index=$((${extract_config_parse_end_index} + 1))
                else
                  break
                fi
              else
                break
              fi
            else
              break
            fi
          done
          extract_config_val_start_index=${extract_config_parse_end_index}
          while [ ${extract_config_val_start_index} -lt ${#extract_config_line} ]; do
            if [ "${extract_config_line:${extract_config_val_start_index}:1}" = ":" ]; then
              break
            fi
            extract_config_val_start_index=$((${extract_config_val_start_index} + 1))
          done
          extract_config_val_start_index=$((${extract_config_val_start_index} + 1))
          while [ ${extract_config_val_start_index} -lt ${#extract_config_line} ]; do
            if [ "${extract_config_line:${extract_config_val_start_index}:1}" = "${tab_character}" ]; then # <tab>
              extract_config_val_start_index=$((${extract_config_val_start_index} + 1))
            else
              if [ "${extract_config_line:${extract_config_val_start_index}:1}" = " " ]; then
                extract_config_val_start_index=$((${extract_config_val_start_index} + 1))
              else
                break
              fi
            fi
          done
          extract_config_val_end_index=$((${#extract_config_line} - 1))
          while [ ${extract_config_val_end_index} -ge ${extract_config_val_start_index} ]; do
            if [ "${extract_config_line:${extract_config_val_end_index}:1}" = "${tab_character}" ]; then # <tab>
              extract_config_val_end_index=$((${extract_config_val_end_index} - 1))
            else
              if [ "${extract_config_line:${extract_config_val_end_index}:1}" = " " ]; then
                extract_config_val_end_index=$((${extract_config_val_end_index} - 1))
              else
                extract_config_val_end_index=$((${extract_config_val_end_index} + 1))
                break
              fi
            fi
          done

          extract_config_parse="${extract_config_line:${extract_config_parse_start_index}:${extract_config_parse_end_index} - ${extract_config_parse_start_index}}"
          extract_config_val="${extract_config_line:${extract_config_val_start_index}:${extract_config_val_end_index} - ${extract_config_val_start_index}}"

          # echo "extract_config_line = \"${extract_config_line}\" (\"${extract_config_parse}\": \"${extract_config_val}\")"
          case "${extract_config_parse}" in
            # (
            "adapter")
              extract_adapter_val="${extract_config_val}"
            ;;

            # (
            "database")
              extract_database_val="${extract_config_val}"
            ;;

            # (
            "username")
              extract_username_val="${extract_config_val}"
            ;;

            # (
            "password")
              extract_password_val="${extract_config_val}"
            ;;
          esac
        fi
      fi
    fi
  done <<< "${extract_yml_file}"

  if [ ! -z "${extract_section_name_val}" ]; then
    append_array_value "${section_names_var}" "${extract_section_name_val}"
    append_array_value "${databases_var}" "${extract_database_val}"
    append_array_value "${usernames_var}" "${extract_username_val}"
    append_array_value "${passwords_var}" "${extract_password_val}"
    if [ -z "${extract_adapter_val}" ]; then
      extract_adapter_val="${default_adapter}"
    fi
    append_array_value "${adapters_var}" "${extract_adapter_val}"
  fi

  IFS="${extract_orig_ifs}"
}

function create_db_users
{
  # This function is more than a bit over the top really,
  # but I do like things to be done properly if I can rather
  # than rely on things being a certain way....
  #
  # So, given an environment, this function looks at the database.yml
  # file, finds the environment and then creates the mysql users that
  # are needed for that environment if necessary.
  #
  # PARAMETERS:
  #   ${1}  - engine_path       - The path to the folder containing the
  #                               config/database.yml file
  #   ${2}  - find_environment  - The environment to setup the DB for.
  #   ${3}  - error_log_file    - The error log file.

  engine_path="${1}"
  find_environment="${2}"
  error_log_file="${3}"

  echo "${return_line}Creating users for the folder: ${engine_path}"
  if [ -f ${engine_path}/config/database.yml ]; then
    has_file_changed ${engine_path}/config/database.yml db_config_changed
    if [ "${db_config_changed}" = "true" ]; then
      echo "found the file: ${engine_path}/config/database.yml"

      declare -a create_db_sections_array
      declare -a create_db_adapters_array
      declare -a create_db_databases_array
      declare -a create_db_usernames_array
      declare -a create_db_passwords_array

      extract_db_configurations "${engine_path}" create_db_sections_array create_db_adapters_array create_db_databases_array create_db_usernames_array create_db_passwords_array

      sections_index=0
      while [ ${sections_index} -lt ${#create_db_sections_array[@]} ]; do
        create_single_user "${create_db_adapters_array[${sections_index}]}" "${create_db_databases_array[${sections_index}]}" "${create_db_usernames_array[${sections_index}]}" "${create_db_passwords_array[${sections_index}]}" "${error_log_file}"
        sections_index=$((${sections_index} + 1))
      done

      archive_file ${engine_path}/config/database.yml
    else
      echo "The file: ${engine_path}/config/database.yml has not changed.  Skipping user creation."
    fi
  fi
}

function check_for_bundle_errors
{
  # The bundler (like everything else) can fail.
  # Interestingly, it doesn't return a non zero value when it does
  # Look for the failure here...
  #
  # PARAMETERS:
  #   ${1}  - bundle_trace_file - The file to check to see if the install has had errors

  bundle_trace_file="${1}"

  bundle_errors_found="false"
  if grep -q "Git error" ${bundle_trace_file}; then
    bundle_errors_found="true"
  fi

  if grep -q "error in your Gemfile" ${bundle_trace_file}; then
    bundle_errors_found="true"
  fi

  if grep -q "^Error " ${bundle_trace_file}; then
    bundle_errors_found="true"
  fi

  if [ "${bundle_errors_found}" = "true" ]; then
    echo "[00;31m************** There was an error when bundling the system. **************[00m" 2>&1 | tee -a ${bundle_trace_file}
    exit 1
  fi
}

function build_compile_assets
{
  # This function could be done inline, but I like the idea of it being a
  # function better.
  # I am keying off the configuration: config.assets.compress = true
  # because this is the best/most reliable way of determining if
  # we should do this that I could find.
  #
  # PARAMETERS:
  #   ${1}  - comp_env      - The environment being checked.
  #   ${2}  - comp_ret_var  - The variable to return the result in

  comp_env="${1}"
  comp_ret_var="${2}"

  cur_compile_dir="$(pwd)"

  com_ret_val="false"
  if grep -q "config.assets.compress *= *true" config/environments/${comp_env}.rb; then
    com_ret_val="true"
  fi

  cd ${cur_compile_dir}

  set_param_value "${comp_ret_var}" "${com_ret_val}"
}

function test_migration
{
  # This function tests to see if the migration succeeded.
  #
  # PARAMETERS:
  #   ${1}  - test_migration_file
  #   ${2}  - test_migration_success_var

  test_migration_file="${1}"
  test_migration_success_var="${2}"

  test_migration_success="0"
  if echo "${test_migration_file}" | grep -qi "Error:"; then
    test_migration_success="1"
  fi

  set_param_value "${test_migration_success_var}" "${test_migration_success}"
}

function build_sub_folder
{
  # This function will build a single folder.
  #
  # Parameters:
  #   ${1}  - base_folder       - The base folder for the project.
  #   ${2}  - build_folder      - The folder to build.
  #   ${3}  - build_environment - The environment to build.  Should be development or production.
  #   ${4}  - skip_install      - Administrative param to allow a call to skip the bundle install.
  #   ${5}  - skip_db_reset     - Administrative param to allow a call to skip resetting the DB.
  #   ${6}  - trace_file        - The file to output all information into...

  base_folder="${1}"
  build_folder="${2}"
  build_environment="${3}"
  skip_install="${4}"
  skip_db_reset="${5}"
  trace_file="${6}"
  start_dir="$(pwd)"

  cd ${base_folder}

  if [ ! -z "${build_folder}" ]; then
    cd ${build_folder}
  fi

  if [ "${skip_install}" != "true" ]; then
    if [ -f "Gemfile" ]; then
      has_file_changed $(pwd)/Gemfile gem_changed
      set +e
      lock_return="$(git ls-files Gemfile.lock --error-unmatch 2>&1)"
      lock_exists="${?}"
      lock_exists="0"
      set -e
      if [ "${lock_exists}" = "0" ]; then
        has_file_changed $(pwd)/Gemfile.lock lock_changed
        if [ "${lock_changed}" = "true" ]; then
          gem_changed="true"
        fi
      fi

      # bundle install it...
      # echo "Doing the bundle install in $(pwd)"
      echo "${return_line}Bundling install..." 2>&1 | tee -a ${trace_file}
      if [ "${gem_changed}" = "true" ]; then
        execute_command "bundle install" ${trace_file} "" ""
        check_for_bundle_errors "${trace_file}"
        archive_file $(pwd)/Gemfile
        if [ "${lock_exists}" = "0" ]; then
          archive_file $(pwd)/Gemfile.lock
        fi
      else
        echo "The gemfile has not changed, the bundle install is being skipped." 2>&1 | tee -a ${trace_file}
      fi

      if [ "${build_environment}" != "development" ]; then
        rake_tasks=$(bundle exec rake -T)
        if echo "${rake_tasks}" | grep "i18n:js:export"; then
          # Generate translation.js file
          # This should only be needed if we are checking in this file, or if we are running a production
          # build.
          # However, it turns out that when we are running the Cucumber tests, we have to have this file
          # so, we have to do it then too...
          echo "${return_line}Raking I18n translations..." 2>&1 | tee -a ${trace_file}
          execute_command "RAILS_ENV=${build_environment} bundle exec rake i18n:js:export" ${trace_file}
        fi

        if echo "${rake_tasks}" | grep "assets:precompile"; then
          cd ${build_base_directory}/${build_folder}
          build_compile_assets "${build_environment}" compile_return
          if [ "${compile_return}" = "true" ]; then
            echo "${return_line}Precompiling the assetss..." 2>&1 | tee -a ${trace_file}
            execute_command "RAILS_ENV=${build_environment} bundle exec rake assets:precompile" ${trace_file}
          fi
        fi
      fi
    fi
  fi

  # This migration shouldn't be needed.  I'm leaving it in the code
  # as a reminder that we may need it...

  #   if [ "${build_folder}" = "s parrow_host" ]; then
  #     # The NAP core model has migrations, and we need to import these into the host.
  #     # echo "Raking the core model..." 2>&1 | tee -a ${trace_file}
  #     echo "
  # Raking the core model... 2>&1 | tee -a ${trace_file}
  # $(pwd) \$ RAILS_ENV=${build_environment} bundle exec rake s parrow_core_models:install:migrations" 2>&1 | tee -a ${trace_file}
  #     RAILS_ENV=${build_environment} bundle exec rake s parrow_core_models:install:migrations 2>&1 | tee -a ${trace_file}
  #   fi

  if [ -d "db" -o -d "spec/dummy/db" ]; then
    # We don't do the "db stuff" in s parrow_crm because the spec_dummy folder in s parrow_crm
    # is really an alias to s parrow_host, so we do/will do it there...
    # if [ "${build_folder}" != "s parrow_crm" ]; then
      build_full_path="$(pwd)"
      is_dummy="false"
      if [ -d "spec/dummy" ]; then
        is_dummy="true"
        cd spec/dummy
      fi

      create_db_users "$(pwd)" "${build_environment}" "${trace_file}"

      # We shouldn't need to do this anymore...
#       if [ "${skip_db_reset}" = "false" ]; then
#         if [ "${build_environment}" = "test" ]; then
#           # Reset the DB.
#           # echo "Dropping the DB in $(pwd)" 2>&1 | tee -a ${trace_file}
#           echo "
# Dropping the database..." 2>&1 | tee -a ${trace_file}
#           execute_command "RAILS_ENV=${build_environment} bundle exec rake db:drop" ${trace_file} "" ""
#         fi
#       fi

      if [ -f ${build_full_path}/config/database.yml ]; then
        set +e
        db_version="$(RAILS_ENV=${build_environment} bundle exec rake db:version 2>&1)"
        version_error="${?}"
        set -e
      else
        version_error="0"
        db_version="Current version: 1"
      fi

      if [ "${version_error}" != "0" ]; then
        if echo "${db_version}" | grep -q "Unknown database"; then
          db_version="Current version: 0"
        else
          echo "${db_version}" 2>&1 | tee -a ${trace_file}
          exit 3
        fi
      fi

      if [ "${db_version:0:17}" != "Current version: " ]; then
        echo "Could not determine the database version." 2>&1 | tee -a ${trace_file}
        exit 3
      fi
      db_version="${db_version:17}"

      echo "${return_line}Database version: ${db_version}" 2>&1 | tee -a ${trace_file}

      if [ ! -f db/schema.rb ]; then
        # if the schema doesn't exist, you have to create it by running migrate.
        # This will force the migrate to run.
        db_version="-1"
      fi

      if [ "${db_version}" = "0" ]; then
        # Setup the DB.
        # The DB Setup includes migrations and seeding.
        # echo "Setting up the DB in $(pwd)" 2>&1 | tee -a ${trace_file}
        echo "${return_line}Setting up the database..." 2>&1 | tee -a ${trace_file}
        execute_command "RAILS_ENV=${build_environment} bundle exec rake db:setup" ${trace_file} "" ""
      else
        # The database exists, do migrations....

        # Rake the DB.
        # echo "Raking the DB in $(pwd)" 2>&1 | tee -a ${trace_file}
        echo "${return_line}Raking the db migration..." 2>&1 | tee -a ${trace_file}
        if [ -f ${build_full_path}/config/database.yml ]; then
          execute_command "RAILS_ENV=${build_environment} bundle exec rake db:migrate" ${trace_file} migrate_success migrate_results

          if [ "${migrate_success}" = "0" ]; then
            test_migration "${migrate_results}" migrate_success
          fi
        fi
        if [ -f ${build_full_path}/config/mongoid.yml ]; then
          execute_command "RAILS_ENV=${build_environment} bundle exec rake db:create_indexes" ${trace_file} migrate_success migrate_results
        fi

        if [ "${migrate_success}" != "0" ]; then
          echo "Database migration has failed, please fix the database before continuing." 2>&1 | tee -a ${trace_file}
          exit 2
        fi

        # Seeding should be OK to do.
        # However, the seed doesn't work properly, so we have to make sure it only runs once.
        # When the platform fixes the seed, this should be removed.
        seed_needed="true"
        # declare -a seed_sections_array
        # declare -a seed_adapters_array
        # declare -a seed_databases_array
        # declare -a seed_usernames_array
        # declare -a seed_passwords_array

        # extract_db_configurations "${engine_path}" seed_sections_array seed_adapters_array seed_databases_array seed_usernames_array seed_passwords_array

        # sections_index=0
        # while [ ${sections_index} -lt ${#seed_sections_array[@]} ]; do
        #   if [ "${seed_sections_array[${sections_index}]}" = "${build_environment}" ]; then
        #     echo "Checking to see if the SOP seed has already been run on ${seed_databases_array[${sections_index}]}"
        #     businesses_exist=$(mysql -D "${seed_databases_array[${sections_index}]}" --user="${seed_usernames_array[${sections_index}]}" --password="${seed_passwords_array[${sections_index}]}" -e "SELECT COUNT(*) as Total FROM ${seed_databases_array[${sections_index}]}.businesses WHERE name = 'sopbusiness'\G" | grep "Total:")
        #     split_line_on_char "${businesses_exist}" ":" total_throw_away num_businesses
        #     ltrim_line "${num_businesses}" num_businesses
        #     if [ "${num_businesses}" -gt 0 ]; then
        #       seed_needed="false"
        #     fi
        #     if [ "${num_businesses}" -gt 1 ]; then
        #       echo "${return_line}The database ${seed_databases_array[${sections_index}]} has ${num_businesses} total \"sopbusiness\" businesses."
        #     fi
        #   fi

        #   sections_index=$((${sections_index} + 1))
        # done

        # The Sage One Platform now provides seed data, so we must seed our databases
        # echo "Seeding the ${build_environment} database..." 2>&1 | tee -a ${trace_file}
        if [ "${seed_needed}" = "true" ]; then
          echo "${return_line}Seeding the ${build_environment} database..." 2>&1 | tee -a ${trace_file}
          execute_command "RAILS_ENV=${build_environment} bundle exec rake db:seed" ${trace_file} migrate_success ""
        else
          echo "${return_line}[00;31mSkipping seeding the database because it was previously seeded, and SOP doesn't work properly if you seed again.[00m"
        fi

        if [ "${migrate_success}" != "0" ]; then
          echo "Database seeding has failed, please fix the database before continuing." 2>&1 | tee -a ${trace_file}
          exit 2
        fi
      fi

      # DON'T call db:test:prepare.  Because we call db:drop db:setup, this call is pointless
      # and actually causes problems.
      #         if [ "${build_environment}" = "test" ]; then
      #           # Prepare the test database.
      #           # NOTE: db:test:prepare doesn't seem to always work, but I don't care if it fails, so
      #           #       I ignore it.
      #           # echo "Preparing the test database in $(pwd)" 2>&1 | tee -a ${trace_file}
      #           echo "
      # Preparing test database... 2>&1 | tee -a ${trace_file}
      # $(pwd) \$ RAILS_ENV=${build_environment} bundle exec rake db:test:prepare" 2>&1 | tee -a ${trace_file}
      #           set +e
      #           RAILS_ENV=${build_environment} bundle exec rake db:test:prepare 2>&1 | tee -a ${trace_file}
      #           set -e
      #         fi

      if [ "${is_dummy}" = "true" ]; then
        cd ../..
      fi
    # fi  # if we are in the s parrow_crm folder...
  fi

  cd ${start_dir}

  if [ -f "spec/dummy/Gemfile" ]; then
    build_sub_folder "${1}" "${2}/spec/dummy" "${3}" "${4}" "${5}" "${6}"
  fi

  # if [ "${build_folder}" = "s parrow_crm" ]; then
  #   build_sub_folder "${base_folder}" "${project_app_directory}" "${build_environment}" "${skip_install}" "${skip_db_reset}" "${trace_file}"
  # fi
}

function build_project
{
  # This function performs the commands needed to "build" the s parrow project.
  build_project_full

  # record_branch recorded_name
  # cd ${build_base_directory}
  # backup_outputs "${build_log_directory}" "build_output.txt" "1w" "7 days"

  # if [ -d "${build_base_directory}/s parrow_crm" ]; then
  #   build_sub_folder ${build_base_directory} "s parrow_crm" "${rails_env_to_use}" "false" "false" "${build_log_directory}/build_output.txt"
  # else
  #   build_project_full
  # fi
  # # build_sub_folder ${build_base_directory} "${project_app_directory}" "${rails_env_to_use}" "false" "false" "${build_log_directory}/build_output.txt"
}

function build_project_full
{
  record_branch recorded_name
  cd ${build_base_directory}
  backup_outputs "${build_log_directory}" "build_output.txt" "1w" "7 days"

  build_sub_folder ${build_base_directory} "." "${rails_env_to_use}" "false" "false" "${build_log_directory}/build_output.txt"
  for directory_name in *; do
    if [ -d ${directory_name} ]; then
      build_sub_folder ${build_base_directory} ${directory_name} "${rails_env_to_use}" "false" "false" "${build_log_directory}/build_output.txt"
      build_sub_folder ${build_base_directory} ${directory_name} "test" "true" "false" "${build_log_directory}/build_output.txt"
    fi
  done
}

function check_rspec_test_run
{
  # This function checks if the test run succeeded or failed...
  #   ${1}  - check_rspec_folder      - The folder the rspec test was run in
  #   ${2}  - test_run_file           - The full path to the file to check
  #   ${3}  - rspec_check_var         - The variable to return the result in
  #   ${4}  - check_failed_lines_var  - The lines that failed.

  check_rspec_folder="${1}"
  test_run_file="${2}"
  rspec_check_var="${3}"
  check_failed_lines_var="${4}"

  rspec_check_return="false"
  if [ -f ${test_run_file} ]; then
    if grep -q ", 0 failures" ${test_run_file}; then
      rspec_check_return="true"
    fi
  fi

  if [ -f ${test_run_file} ]; then
    if grep -q "Failed examples:" ${test_run_file}; then
      rspec_check_return="false"

      # Find the lines that show which scenarios failed.
      rspec_grep_result="$(grep -n "Failed examples:" ${test_run_file})"
      get_line_number "${rspec_grep_result}" "true" rspec_start_line
      rspec_start_line=$(( ${rspec_start_line} + 1))
      rspec_grep_result="$(wc -l ${test_run_file})"
      # rspec_grep_result="$(grep -n "(See full trace by running task with --trace)" ${test_run_file})"
      get_line_number "${rspec_grep_result}" "false" rspec_end_line
      rspec_num_tail_lines=$((${rspec_end_line} - ${rspec_start_line}))

      # Go through each line and see if it is expected.
      rspec_tail_lines="$(tail -n${rspec_num_tail_lines} ${test_run_file})"
      # rspec_unknown_errors="false"
      while read rspec_error_line; do
        if [ -z "${rspec_error_line}" ]; then
          break
        fi
        if [ ${#rspec_error_line} -lt 6 ]; then
          break
        fi
        if [ "${rspec_error_line:0:6}" != "rspec " ]; then
          break
        fi

        append_array_value "${check_failed_lines_var}" "${check_rspec_folder}-${rspec_error_line}"
      done <<< "${rspec_tail_lines}"
    fi
  fi

  set_param_value "${rspec_check_var}" "${rspec_check_return}"
}

function get_line_number
{
  # This funciton will extract the line number from a grep
  #
  # Parameters:
  #   ${1}  - grep_line   - The line from grep that has the line number
  #   ${2}  - from_grep   - The line is from a grep.
  #   ${3}  - line_return - The variable to return the line number into

  grep_line="${1}"
  from_grep="${2}"
  line_return="${3}"
  line_num=0
  colon_pos=0
  start_pos=0

  while [ "${start_pos}" -lt "${#grep_line}" ]; do
    if [ "${grep_line:${start_pos}:1}" != " " ]; then
      break
    fi
    start_pos=$((${start_pos} + 1))
  done

  colon_pos=${start_pos}
  while [ "${colon_pos}" -lt "${#grep_line}" ]; do
    if [ "${grep_line:${colon_pos}:1}" = " " ]; then
      break
    fi
    if [ "${grep_line:${colon_pos}:1}" = ":" ]; then
      break
    fi
    colon_pos=$((${colon_pos} + 1))
  done
  if [ "${from_grep}" = "true" -a "${colon_pos}" -ge "${#grep_line}" ]; then
    colon_pos="-1"
  fi

  if [ "${colon_pos}" -gt "0" ]; then
    line_num=${grep_line:${start_pos}:${colon_pos} - ${start_pos}}
  fi

  set_param_value "${line_return}" "${line_num}"
}

function test_smoke_fails
{
  # This function tests the passed in file name to see if the
  # cucumber tests succeeded.  There are some expected failures.
  # If we see those, we ignore them.  If not, then the test failed.
  #
  # Parameters:
  #   ${1}  - test_smoke_directory          - The directory name for the smoke tests
  #   ${2}  - test_smoke_file               - The full path to the file to check
  #   ${3}  - check_smoke_var               - The variable to return the result in
  #   ${4}  - fail_lines_folder_return      - The folder that the feature failed in.
  #   ${5}  - fail_lines_return             - The lines that were not expected that failed
  #   ${6}  - rspec_fail_lines_return       - The lines that were not expected that failed
  #   ${7}  - test_smoke_missing_steps_var  - An array variable to return missing steps in.

  test_smoke_directory="${1}"
  test_smoke_file="${2}"
  check_smoke_var="${3}"
  fail_lines_folder_return="${4}"
  fail_lines_return="${5}"
  rspec_fail_lines_return="${6}"
  test_smoke_missing_steps_var="${7}"

  declare -a expected_errors
  fail_lines=""
  found_count=0

  if [ -f ${proj_dir}/expected_errors_for_build_project ]; then
    error_lines=$(cat ${proj_dir}/settings_for_build_project)
    while read exec_error_line; do
      eval ${exec_error_line}
    done <<< "${error_lines}"
  fi
  # expected_errors[${#expected_errors[@]}]="suggest search and link Twitter profile"
  # expected_errors[${#expected_errors[@]}]="Link Twitter profile"

  smoke_check_return="false"
  if [ -f ${test_smoke_file} ]; then
    smoke_check_return="true"
    if grep -q "steps.*[1-9] failed" ${test_smoke_file}; then
      # unknown error, the user will have to check the log file...
      smoke_check_return="false"
    fi

    if grep -q "Failed examples:" ${test_smoke_file}; then
      # ci:smoke runs a rake test, see if this is what failed...
      smoke_check_return="false"
      check_rspec_test_run "${test_smoke_directory}" "${test_smoke_file}" smoke_rspec_success "${rspec_fail_lines_return}"
    fi

    if grep -q "You can implement step definitions for undefined steps with these snippets:" ${test_smoke_file}; then
      smoke_check_return="false"

      # Find the lines that show which scenarios failed.
      grep_result="$(grep -n "You can implement step definitions for undefined steps with these snippets:" ${test_smoke_file})"
      get_line_number "${grep_result}" "true" start_line
      grep_result="$(wc -l ${test_smoke_file})"
      get_line_number "${grep_result}" "false" end_line
      num_tail_lines=$((${end_line} - ${start_line}))

      # Go through each line and see if it is expected.
      tail_lines="$(tail -n${num_tail_lines} ${test_smoke_file})"
      unknown_errors="false"
      in_step_definition="false"
      while read step_line; do
        if [ ! -z "${step_line}" ]; then
          if echo "${step_line}" | grep "/\^.*\$/"; then
            append_array_value "${test_smoke_missing_steps_var}" "${step_line}"
            in_step_definition="true"
          else
            if [ "${in_step_definition}" = "false" ]; then
              break
            fi
          fi
        else
          in_step_definition="false"
        fi
      done <<< "${tail_lines}"
    fi

    if grep -q "Failing Scenarios:" ${test_smoke_file}; then
      # Find the lines that show which scenarios failed.
      grep_result="$(grep -n "Failing Scenarios:" ${test_smoke_file})"
      get_line_number "${grep_result}" "true" start_line
      grep_result="$(wc -l ${test_smoke_file})"
      get_line_number "${grep_result}" "false" end_line
      num_tail_lines=$((${end_line} - ${start_line}))

      # Go through each line and see if it is expected.
      tail_lines="$(tail -n${num_tail_lines} ${test_smoke_file})"
      unknown_errors="false"
      while read error_line; do
        if [ -z "${error_line}" ]; then
          break
        fi

        is_new_error_line="false"
        if [ ${#error_line} -gt 9 ]; then
          if [ "${error_line:0:9}" = "cucumber " ]; then
            is_new_error_line="true"
          fi
        fi

        if [  "${is_new_error_line}" = "true" ]; then
          if [ ! -z "${fail_lines}" ]; then
            append_array_value "${fail_lines_folder_return}" "${test_smoke_directory}"
            append_array_value "${fail_lines_return}" "${fail_lines}"
          fi
          split_failed_line "${error_line}" test_error_cucumber test_error_scenario

          error_index=0
          while [ "${error_index}" -lt "${#expected_errors[@]}" ]; do
            if echo "${test_error_scenario}" | grep -q "${expected_errors[${error_index}]}"; then
              found_count=$((${found_count} + 1))
              break
            fi
            error_index=$((${error_index} + 1))
          done

          # If the line isn't found, it wasn't expected.
          if [ "${error_index}" -ge "${#expected_errors[@]}" ]; then
            unknown_errors="true"

            fail_lines="${error_line}"
          fi
        else
          fail_lines="${fail_lines}${return_line}${error_line}"
        fi
      done <<< "${tail_lines}"
      if [ ! -z "${fail_lines}" ]; then
        append_array_value "${fail_lines_folder_return}" "${test_smoke_directory}"
        append_array_value "${fail_lines_return}" "${fail_lines}"
      fi

      if [ "${unknown_errors}" = "true" ]; then
        smoke_check_return="false"
      # else
        # # Make sure that all of the expected fails are seen.
        # if [ "${found_count}" -ne "${#expected_errors[@]}" ]; then
        #   # smoke_check_return="false"
        #   smoke_check_return="true"
        # else
        #   smoke_check_return="true"
        # fi
      fi
    fi
  fi

  # Return success or failure.
  set_param_value "${check_smoke_var}" "${smoke_check_return}"
}

function split_failed_line
{
  # This function splits a failed line into the cucumber command and the name of the test.
  #
  # PARAMETERS:
  #   ${1}  - failed_line_to_split  - The line to split into portions
  #   ${2}  - cucumber_portion_var  - The variable into which to return the cucumber command
  #   ${3}  - test_name_portion_var - The variable into which to return the test name
  #
  # Sample line:
  # cucumber -p firefox -p target-local -p no-manual-tests -p no-stage-tests -p no-wip-tests
  #   -p browser-firefox -p standard features/platform/contacts/contact_detail.feature:45
  #   # Scenario: User cannot save

  failed_line_to_split="${1}"
  cucumber_portion_var="${2}"
  test_name_portion_var="${3}"

  cucumber_value=""
  scenario_name=""

  split_fail_comment_pos=0
  while [ ${split_fail_comment_pos} -lt ${#failed_line_to_split} ]; do
    if [ "${failed_line_to_split:${split_fail_comment_pos}:1}" = "#" ]; then
      break
    fi
    split_fail_comment_pos=$((${split_fail_comment_pos} + 1))
  done
  split_fail_comment_pos=$((${split_fail_comment_pos} - 1))
  while [ ${split_fail_comment_pos} -ge 0 ]; do
    if [ "${failed_line_to_split:${split_fail_comment_pos}:1}" != " " ]; then
      break
    fi
    split_fail_comment_pos=$((${split_fail_comment_pos} - 1))
  done
  split_fail_comment_pos=$((${split_fail_comment_pos} + 1))
  if [ ${split_fail_comment_pos} -lt ${#failed_line_to_split} ]; then
    cucumber_value="${failed_line_to_split:0:${split_fail_comment_pos}}"
  else
    cucumber_value="${failed_line_to_split}"
  fi

  while [ ${split_fail_comment_pos} -lt ${#failed_line_to_split} ]; do
    if [ "${failed_line_to_split:${split_fail_comment_pos}:1}" = ":" ]; then
      break
    fi
    split_fail_comment_pos=$((${split_fail_comment_pos} + 1))
  done
  split_fail_comment_pos=$((${split_fail_comment_pos} + 1))
  while [ ${split_fail_comment_pos} -lt ${#failed_line_to_split} ]; do
    if [ "${failed_line_to_split:${split_fail_comment_pos}:1}" != " " ]; then
      break
    fi
    split_fail_comment_pos=$((${split_fail_comment_pos} + 1))
  done
  if [ ${split_fail_comment_pos} -lt ${#failed_line_to_split} ]; then
    scenario_name="${failed_line_to_split:${split_fail_comment_pos}}"
  fi

  set_param_value "${cucumber_portion_var}" "${cucumber_value}"
  set_param_value "${test_name_portion_var}" "${scenario_name}"
}

function retest_lines
{
  # Because many of the tests are kinda brittle, I want to have the system
  # re-run the failed tests to see if they are realy failing.
  #
  # PARAMETERS:
  #   ${1}  - retest_folder_name      - The name of the folder being retested.
  #   ${2}  - failed_retest_lines_var - Lines to retest
  #   ${3}  - retest_log              - The log file to output information to.
  #   ${4}  - retest_success          - Return variable for if the retest succeeds.
  #   ${5}  - retest_line_results_var - Return variable for if the retest succeeds.

  retest_folder_name="${1}"
  failed_retest_lines_var="${2}"
  retest_log="${3}"
  retest_success="${4}"
  retest_line_results_var="${5}"

  declare -a retest_mising_steps
  declare -a retest_failed_folders
  declare -a retest_failed_lines
  declare -a retest_rspec_failed_lines

  eval "num_fail_retests=\${#${failed_retest_lines_var}[@]}"
  get_line_number "${num_fail_retests}" "false" num_fail_retests

  mkdir -p ${build_log_directory}

  re_run_number=0
  while [ ${re_run_number} -lt ${num_fail_retests} ]; do
    eval "line_to_retest=\${${failed_retest_lines_var}[${re_run_number}]}"
    test_retest_success="true"

    re_run_number=$((${re_run_number} + 1))
    split_failed_line "${line_to_retest}" retest_cucumber retest_scenario

    if [ "${retest_cucumber:0:8}" = "cucumber" ]; then
      if [ -f ${build_log_directory}/retest_single_run.txt ]; then
        rm ${build_log_directory}/retest_single_run.txt
      fi

      cd ${build_base_directory}/${retest_folder_name}
      format_line "Re-running failed cucumber test (${re_run_number}/${num_fail_retests}): ${retest_scenario}...${return_line}${return_line}" "" retest_notice_line_format
      echo "${return_line}${return_line}${retest_notice_line_format}" 2>&1 | tee -a ${build_log_directory}/retest_single_run.txt

      retest_fail_break="false"
      execute_command "bundle exec ${retest_cucumber}" ${build_log_directory}/retest_single_run.txt alt_retest_fail ""

      cat ${build_log_directory}/retest_single_run.txt >> ${retest_log}

      # Test cucumber results...
      test_smoke_fails "${retest_folder_name}" ${build_log_directory}/retest_single_run.txt sub_test_retest_success retest_failed_folders retest_failed_lines retest_rspec_failed_lines retest_mising_steps
      if [ "${sub_test_retest_success}" = "false" ]; then
        test_retest_success="false"
      fi

      if [ -f ${build_log_directory}/retest_single_run.txt ]; then
        rm ${build_log_directory}/retest_single_run.txt
      fi
    else
      test_retest_success="false"
    fi

    append_array_value "${retest_line_results_var}" "${test_retest_success}"

    # if [ "${test_retest_success}" = "false" ]; then
    #   break
    # fi
  done

  set_param_value "${retest_success}" "${test_retest_success}"
}

function test_rspec
{
  # This function will run the rspec tests for a specific folder
  # and return the success or failure.
  #
  # PARAMETERS
  #   ${1}  - rspec_folder                - The folder to run the rspec tests in.
  #   ${2}  - rspec_line                  - The line of the test to run (if any)
  #   ${3}  - test_rspec_skip_db_reset    - Skip the DB setup
  #   ${4}  - rspec_trace_file            - The file to trace the output to.
  #   ${5}  - rspec_success_var           - The variable to return the success in.
  #   ${6}  - test_rspec_failed_lines_var - Returns the failed lines of the test/s

  rspec_folder="${1}"
  rspec_line="${2}"
  test_rspec_skip_db_reset="${3}"
  rspec_trace_file="${4}"
  rspec_success_var="${5}"
  test_rspec_failed_lines_var="${6}"

  rspec_test_success="true"

  rspec_file_exists="true"
  if [ ! -z "${rspec_line}" ]; then
    split_line_on_char "${rspec_line}" ":" rspec_line_file_name rspec_line_number
    if [ ! -f "${build_base_directory}/${rspec_folder}/spec/${rspec_line_file_name}" ]; then
      rspec_file_exists="false"
    fi
  fi

  if [ "${rspec_file_exists}" = "true" ]; then
    if [ -d ${build_base_directory}/${rspec_folder} ]; then
      cd ${build_base_directory}/${rspec_folder}
      if [ -d "spec" ]; then
        if [ -f ${build_log_directory}/rspec_single_run.txt ]; then
          rm ${build_log_directory}/rspec_single_run.txt
        fi

        build_sub_folder ${build_base_directory} ${rspec_folder} "test" "false" "${test_rspec_skip_db_reset}" "${build_log_directory}/rspec_single_run.txt"

        # Run the rspec test.
        # echo "Testing the package $(pwd)"
        echo "${return_line}Testing package..." 2>&1 | tee -a ${build_log_directory}/rspec_single_run.txt
        execute_command "bundle exec rspec spec/${rspec_line}" ${build_log_directory}/rspec_single_run.txt rspec_test_fail_break ""
        if [ "${rspec_test_fail_break}" -ne "0" ]; then
          rspec_test_fail_break="true"
        else
          rspec_test_fail_break="false"
        fi

        cat ${build_log_directory}/rspec_single_run.txt >> ${rspec_trace_file}

        # test the output...
        check_rspec_test_run "${rspec_folder}" ${build_log_directory}/rspec_single_run.txt rspec_test_success "${test_rspec_failed_lines_var}"

        # Delete the temporary backup file...
        if [ -f ${build_log_directory}/rspec_single_run.txt ]; then
          rm ${build_log_directory}/rspec_single_run.txt
        fi
      fi
      cd ..
    fi

    if [ "${rspec_test_fail_break}" = "true" -o "${rspec_test_success}" = "false" ]; then
      rspec_test_success="false"
    fi
  fi

  set_param_value "${rspec_success_var}" "${rspec_test_success}"
}

function test_smoke
{
  # This function only runs the CI:Smoke.
  #
  # PARAMETERS:
  #   ${1}  - smoke_ci_folder             - folder to try to run the smoke ci in
  #   ${2}  - smoke_ci_type               - smoke or cucumber for the CI command
  #   ${3}  - smoke_log_file              - The log file to output the log to
  #   ${4}  - smoke_success_var           - The variable to return success or failure in
  #   ${5}  - smoke_fail_folders_var      - The variable to return the lines that failed in
  #   ${6}  - smoke_fail_lines_var        - The variable to return the lines that failed in
  #   ${7}  - smoke_rspec_fail_lines_var  - The variable to return the lines that failed in
  #   ${8}  - smoke_retest_lines_var      - The variable to return the results of retesting the lines.
  #   ${9}  - smoke_missing_steps_var     - The array variable to return the missing steps in.

  smoke_ci_folder="${1}"
  smoke_ci_type="${2}"
  smoke_log_file="${3}"
  smoke_success_var="${4}"
  smoke_fail_folders_var="${5}"
  smoke_fail_lines_var="${6}"
  smoke_rspec_fail_lines_var="${7}"
  smoke_retest_lines_var="${8}"
  smoke_missing_steps_var="${9}"

  smoke_test_success="true"
  smoke_local_params="${user_smoke_params}"

  will_feature_tests_run "${smoke_ci_folder}" smoke_can_run
  if [ ! -f ${build_base_directory}/${smoke_ci_folder}/lib/tasks/ci.rake ]; then
    smoke_can_run="false"
  fi

  if [ "${smoke_can_run}" = "true" ]; then
    if [ -f ${build_log_directory}/smoke_single_run.txt ]; then
      rm ${build_log_directory}/smoke_single_run.txt
    fi

    # if a -p option hasn't been set, add a -p option to the options...
    if [ "${smoke_browser_set}" = "false" ]; then
      if [ ! -z "${smoke_local_params}" ]; then
        smoke_local_params="${smoke_local_params} "
      fi

      # What option to use depends on which branch has or hasn't been merged to master yet...
      if grep "browser-webkit\:" ${build_base_directory}/${smoke_ci_folder}/config/cucumber.yml; then
        smoke_local_params="${smoke_local_params}-p webkit"
      else
        smoke_local_params="${smoke_local_params}-p firefox"
      fi
    fi

    cd ${build_base_directory}/${smoke_ci_folder}
    echo "Testing CI..." 2>&1 | tee -a ${build_log_directory}/smoke_single_run.txt
    execute_command "bundle exec rake ${smoke_ci_type}'[${smoke_local_params}]'" ${build_log_directory}/smoke_single_run.txt smoke_fail_result ""

    cat ${build_log_directory}/smoke_single_run.txt >> ${smoke_log_file}

    # Test cucumber results...
    test_smoke_fails "${smoke_ci_folder}" ${build_log_directory}/smoke_single_run.txt smoke_test_success "${smoke_fail_folders_var}" "${smoke_fail_lines_var}" "${smoke_rspec_fail_lines_var}" "${smoke_missing_steps_var}"

    if [ -f ${build_log_directory}/smoke_single_run.txt ]; then
      rm ${build_log_directory}/smoke_single_run.txt
    fi

    eval "num_smoke_fail_lines=\${#${smoke_fail_lines_var}[@]}"
    if [ ${num_smoke_fail_lines} -gt 0 ]; then
      smoke_test_success="false"
      retest_lines "${smoke_ci_folder}" "${smoke_fail_lines_var}" "${smoke_log_file}" smoke_test_success "${smoke_retest_lines_var}"
    fi
  fi

  set_param_value "${smoke_success_var}" "${smoke_test_success}"
}

function report_test_success
{
  # This function reports on if the tests succeeded or failed.
  #
  # PARAMETERS:
  #   ${1}  - report_log                  - The log file to report into.
  #   ${2}  - report_success              - If the tests succeeded or not
  #   ${3}  - report_failed_folders       - The folders of the failed reports if applicable.
  #   ${4}  - report_failed_lines         - The lines of the failed reports if applicable.
  #   ${5}  - report_failed_status_lines  - The status of the retest of the failed lines.
  #   ${6}  - report_failed_rspec_lines   - The lines of the faile rspec tests if applicable.
  #   ${7}  - report_menu_types           - An array of the menu list of types
  #   ${8}  - report_file_names           - An array of the menu list of file names
  #   ${9}  - report_sub_file_names       - An array of the menu list of sub file names
  #   ${10} - report_missing_steps        - An array of missing step definitions

  report_log="${1}"
  report_success="${2}"
  declare -a report_failed_folders=("${!3}")
  declare -a report_failed_lines=("${!4}")
  declare -a report_failed_status_lines=("${!5}")
  declare -a report_failed_rspec_lines=("${!6}")
  declare -a report_menu_types=("${!7}")
  declare -a report_file_names=("${!8}")
  declare -a report_sub_file_names=("${!9}")
  # Because there are more than 9 parameters...
  shift
  declare -a report_missing_steps=("${!9}")

  if [ ${#report_failed_rspec_lines[@]} -gt 0 ]; then
    format_line "The following RSPEC tests failed:" "" report_print_line
    echo "${return_line}${report_print_line}" 2>&1 | tee -a ${report_log}
    report_failed_line_index=0
    while [ ${report_failed_line_index} -lt ${#report_failed_rspec_lines[@]} ]; do
      failed_line_details="${report_failed_rspec_lines[${report_failed_line_index}]}"

      split_line_on_char "${failed_line_details}" "#" rspec_command_line rspec_description_line
      rtrim_line "${rspec_command_line}" rspec_command_line
      ltrim_line "${rspec_description_line}" rspec_description_line
      split_line_on_char "${rspec_command_line}" "-" report_rspec_folder rspec_command_line
      split_line_on_char "${rspec_command_line}" ":" rspec_command_line rspec_command_line_number

      if [ ! -z "${rspec_command_line_number}" ]; then
        rspec_command_line_number=":${rspec_command_line_number}"
      fi

      find_test_index=0
      while [ ${find_test_index} -lt ${#report_menu_types[@]} ]; do
        if [ "${report_menu_types[${find_test_index}]}" = "rspec" ]; then
          if [ "${report_file_names[${find_test_index}]}" = "${report_rspec_folder}" ]; then
            if [ "${report_sub_file_names[${find_test_index}]}" = "${rspec_command_line:13}" ]; then
              report_build_project_test_params="${find_test_index}${rspec_command_line_number}"
              break
            fi
          fi
        fi
        find_test_index=$((${find_test_index} + 1))
      done

      if [ ${report_failed_line_index} -gt 0 ]; then
        echo "" 2>&1 | tee -a ${report_log}
      fi
      format_line_for_menu "$((${report_failed_line_index} + 1))" "" "${rspec_description_line}" report_print_line
      echo "${report_print_line}" 2>&1 | tee -a ${report_log}

      echo "" 2>&1 | tee -a ${report_log}
      if [ ! -z "${report_build_project_test_params}" ]; then
        echo "./build_project ---test --test-params \"${report_build_project_test_params}\"" 2>&1 | tee -a ${report_log}
      fi
      echo "cd ${build_base_directory}/${report_rspec_folder}" 2>&1 | tee -a ${report_log}
      echo "bundle exec ${rspec_command_line}${rspec_command_line_number}" 2>&1 | tee -a ${report_log}

      report_failed_line_index=$((${report_failed_line_index} + 1))
    done
  fi

  if [ "${#report_failed_lines[@]}" -gt 0 ]; then
    echo "${return_line}The following tests failed and had to be retested:" 2>&1 | tee -a ${report_log}
    report_failed_line_index=0
    while [ ${report_failed_line_index} -lt ${#report_failed_lines[@]} ]; do
      failed_line_folder="${report_failed_folders[${report_failed_line_index}]}"
      failed_line_details="${report_failed_lines[${report_failed_line_index}]}"
      line_fail_status="${report_failed_status_lines[${report_failed_line_index}]}"

      split_failed_line "${failed_line_details}" report_failed_cucumber report_failed_scenario

      report_cucumber_file_name="${report_failed_cucumber}"
      while [ ! -z "${report_cucumber_file_name}" ]; do
        split_line_on_char "${report_cucumber_file_name}" " " cucumber_param report_cucumber_file_name
      done
      report_cucumber_file_name="${cucumber_param}"
      split_line_on_char "${report_cucumber_file_name}" ":" report_cucumber_file_name cucumber_param

      if [ ! -z "${cucumber_param}" ]; then
        cucumber_param=":${cucumber_param}"
      fi

      find_test_index=0
      while [ ${find_test_index} -lt ${#report_menu_types[@]} ]; do
        if [ "${report_menu_types[${find_test_index}]}" = "feature" ]; then
          if [ "${report_file_names[${find_test_index}]}" = "${report_cucumber_file_name}" -a "${report_sub_file_names[${find_test_index}]}" = "${failed_line_folder}" ]; then
            report_build_project_test_params="${find_test_index}${cucumber_param}"
            break
          fi
        fi
        find_test_index=$((${find_test_index} + 1))
      done

      if [ ${report_failed_line_index} -gt 0 ]; then
        echo "" 2>&1 | tee -a ${report_log}
      fi
      format_line_for_menu "$((${report_failed_line_index} + 1))" "" "${report_failed_scenario}" report_print_line
      echo "${report_print_line}" 2>&1 | tee -a ${report_log}

      if [ "${line_fail_status}" = "true" ]; then
        echo "      [00;32mRetest succeeded!!![00m" 2>&1 | tee -a ${report_log}
      else
        echo "      [00;31mTest failed!!!!![00m" 2>&1 | tee -a ${report_log}
        echo "" 2>&1 | tee -a ${report_log}
        if [ ! -z "${report_build_project_test_params}" ]; then
          echo "./build_project ---test --test-params \"${report_build_project_test_params}\"" 2>&1 | tee -a ${report_log}
        fi
        echo "cd ${build_base_directory}/${failed_line_folder}" 2>&1 | tee -a ${report_log}
        echo "bundle exec ${report_failed_cucumber}" 2>&1 | tee -a ${report_log}
      fi

      report_failed_line_index=$((${report_failed_line_index} + 1))
    done
  fi

  if [ ${#report_missing_steps[@]} -gt 0 ]; then
    echo "${return_line}The following steps are missing:" 2>&1 | tee -a ${report_log}
    report_failed_line_index=0
    while [ ${report_failed_line_index} -lt ${#report_missing_steps[@]} ]; do
      if [ ${report_failed_line_index} -gt 0 ]; then
        echo "" 2>&1 | tee -a ${report_log}
      fi
      format_line_for_menu "$((${report_failed_line_index} + 1))" "" "[00;31m${report_missing_steps[${report_failed_line_index}]}[00m" report_print_line
      echo "${report_print_line}" 2>&1 | tee -a ${report_log}

      report_failed_line_index=$((${report_failed_line_index} + 1))
    done
  fi

  # If the test failed, exit.
  if [ "${report_success}" = "false" ]; then
    echo "[00;31m************** Test failed!!!!! **************[00m" 2>&1 | tee -a ${report_log}

    format_line "For additional information, please refer to the output file:" "" fail_report_text
    echo "${fail_report_text}"
    echo "${report_log}"

    exit 1
  fi

  echo "[00;32mTest succeeded!!![00m" 2>&1 | tee -a ${report_log}
}

function run_smoke_test
{
  # This function only runs the CI:Smoke.
  #
  # PARAMETERS:
  #   ${1}  - run_smoke_ci_type                     - smoke or cucumber for the ci: type.
  #   ${2}  - run_smoke_directory                   - The directory to run the smoke in.
  #   ${3}  - run_smoke_test_success_var            - The variable to return the success in
  #   ${4}  - run_smoke_test_failed_folders_var     - The variable to return the failed folders in
  #   ${5}  - run_smoke_test_failed_lines_var       - The variable to return the failed lines in
  #   ${6}  - run_smoke_test_rspec_failed_lines_var - The variable to return the failed lines in
  #   ${7}  - run_smoke_test_retest_var             - The variable to return the retest results in
  #   ${8}  - test_run_smoke_missing_steps_var      - The array variable to return the missing steps in

  run_smoke_ci_type="${1}"
  run_smoke_directory="${2}"
  run_smoke_test_success_var="${3}"
  run_smoke_test_failed_folders_var="${4}"
  run_smoke_test_failed_lines_var="${5}"
  run_smoke_test_rspec_failed_lines_var="${6}"
  run_smoke_test_retest_var="${7}"
  test_run_smoke_missing_steps_var="${8}"

  test_smoke_success="true"

  if [ -d ${build_base_directory}/${run_smoke_directory} ]; then
    cd ${build_base_directory}
    record_branch recorded_name
    backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"

    test_smoke "${run_smoke_directory}" "${run_smoke_ci_type}" "${build_log_directory}/test_run.txt" test_smoke_success "${run_smoke_test_failed_folders_var}" "${run_smoke_test_failed_lines_var}" "${run_smoke_test_rspec_failed_lines_var}" "${run_smoke_test_retest_var}" "${test_run_smoke_missing_steps_var}"
  fi

  set_param_value "${run_smoke_test_success_var}" "${test_smoke_success}"
}

function test_feature
{
  # This function will run the feature tests for a specific file
  # and return the success or failure.
  #
  # PARAMETERS
  #   ${1}  - single_feature_folder                 - The folder to run the feature tests in.
  #   ${2}  - single_feature_file                   - The file to run the feature tests on.
  #   ${3}  - single_feature_trace_file             - The file to trace the output to.
  #   ${4}  - single_feature_success_var            - The variable to return the success in.
  #   ${5}  - single_feature_failed_folders_var     - The variable to return the failed folders in.
  #   ${6}  - single_feature_failed_lines_var       - The variable to return the failed lines in.
  #   ${7}  - single_feature_rspec_failed_lines_var - The variable to return the failed lines in.
  #   ${8}  - single_feature_failed_status_var      - The variable to return the retest status in.
  #   ${9}  - single_feature_missing_steps_var      - The array variable to return the missing steps in.

  cd ${build_base_directory}

  single_feature_folder="${1}"
  single_feature_file="${2}"
  single_feature_trace_file="${3}"
  single_feature_success_var="${4}"
  single_feature_failed_folders_var="${5}"
  single_feature_failed_lines_var="${6}"
  single_feature_rspec_failed_lines_var="${7}"
  single_feature_failed_status_var="${8}"
  single_feature_missing_steps_var="${9}"

  single_feature_test_success="false"

  will_feature_tests_run "${single_feature_folder}" feature_can_run
  if [ ! -f ${build_base_directory}/${single_feature_folder}/lib/tasks/ci.rake ]; then
    smoke_can_run="false"
  fi

  single_smoke_local_params="${user_smoke_params}"

  if [ "${feature_can_run}" = "true" ]; then
    single_feature_test_success="true"

    # if a -p option hasn't been set, add a -p option to the options...
    if [ "${smoke_browser_set}" = "false" ]; then
      if [ ! -z "${single_smoke_local_params}" ]; then
        single_smoke_local_params="${single_smoke_local_params} "
      fi

      # What option to use depends on which branch has or hasn't been merged to master yet...
      if grep "browser-webkit\:" ${build_base_directory}/${smoke_ci_folder}/config/cucumber.yml; then
        single_smoke_local_params="${single_smoke_local_params}-p webkit"
      else
        single_smoke_local_params="${single_smoke_local_params}-p firefox"
      fi
    fi

    split_line_on_char "${single_feature_file}" ":" single_feature_file_name single_feature_file_line
    if [ -f ${build_base_directory}/${single_feature_folder}/${single_feature_file_name} ]; then
      cd ${build_base_directory}/${single_feature_folder}

      if [ -f ${build_log_directory}/feature_single_run.txt ]; then
        rm ${build_log_directory}/feature_single_run.txt
      fi

      # Run the feature test.
      echo "${return_line}Testing feature..." 2>&1 | tee -a ${build_log_directory}/feature_single_run.txt
      execute_command "bundle exec cucumber ${single_feature_file} ${single_smoke_local_params}" ${build_log_directory}/feature_single_run.txt single_feature_test_fail_break ""
      if [ "${single_feature_test_fail_break}" -ne "0" ]; then
        single_feature_test_fail_break="true"
      else
        single_feature_test_fail_break="false"
      fi

      cat ${build_log_directory}/feature_single_run.txt >> ${single_feature_trace_file}

      # Test cucumber results...
      test_smoke_fails "${single_feature_folder}" ${build_log_directory}/feature_single_run.txt single_feature_test_success "${single_feature_failed_folders_var}" "${single_feature_failed_lines_var}" "${single_feature_rspec_failed_lines_var}" "${single_feature_missing_steps_var}"

      if [ -f ${build_log_directory}/feature_single_run.txt ]; then
        rm ${build_log_directory}/feature_single_run.txt
      fi

      eval "num_single_feature_failed_lines=\${#${single_feature_failed_lines_var}[@]}"
      if [ "${num_single_feature_failed_lines}" -gt 0 ]; then
        smoke_test_success="false"
        retest_lines "${single_feature_folder}" "${single_feature_failed_lines_var}" "${single_feature_trace_file}" single_feature_test_success "${single_feature_failed_status_var}"
      fi
    fi

    if [ "${single_feature_test_fail_break}" = "true" -o "${single_feature_test_success}" = "false" ]; then
      single_feature_test_success="false"
    fi
  fi

  set_param_value "${single_feature_success_var}" "${single_feature_test_success}"
}

function ltrim_line
{
  # This function splits a feature file name into two halves:  The folder to run the tests in
  # and the path to the file to be run.
  #
  # PARAMETERS:
  #   ${1}  - line_to_trim    - The line of text to trim spaces off of
  #   ${2}  - trim_return_var - The return value.

  line_to_trim="${1}"
  trim_return_var="${2}"

  trim_position=0
  while [ ${trim_position} -lt ${#line_to_trim} ]; do
    if [ "${line_to_trim:${trim_position}:1}" != " " ]; then
      break
    fi
    trim_position=$((${trim_position} + 1))
  done

  if [ ${trim_position} -lt ${#line_to_trim} ]; then
    trimmed_value="${line_to_trim:${trim_position}}"
  else
    trimmed_value=""
  fi

  set_param_value "${trim_return_var}" "${trimmed_value}"
}

function rtrim_line
{
  # This function splits a feature file name into two halves:  The folder to run the tests in
  # and the path to the file to be run.
  #
  # PARAMETERS:
  #   ${1}  - line_to_trim    - The line of text to trim spaces off of
  #   ${2}  - trim_return_var - The return value.

  line_to_trim="${1}"
  trim_return_var="${2}"

  trim_position=${#line_to_trim}
  while [ ${trim_position} -gt 0 ]; do
    trim_position=$((${trim_position} - 1))
    if [ "${line_to_trim:${trim_position}:1}" != " " ]; then
      break
    fi
  done

  if [ ${trim_position} -gt 0 ]; then
    trimmed_value="${line_to_trim:0:${trim_position} + 1}"
  else
    trimmed_value=""
  fi

  set_param_value "${trim_return_var}" "${trimmed_value}"
}

function split_line_on_char
{
  # This function splits a feature file name into two halves:  The folder to run the tests in
  # and the path to the file to be run.
  #
  # PARAMETERS:
  #   ${1}  - line_to_split
  #   ${2}  - character_to_split_on
  #   ${3}  - left_side_var
  #   ${4}  - right_side_var

  line_to_split="${1}"
  character_to_split_on="${2}"
  left_side_var="${3}"
  right_side_var="${4}"

  split_position=0
  while [ $((${split_position} + ${#character_to_split_on} - 1)) -lt ${#line_to_split} ]; do
    if [ "${line_to_split:${split_position}:${#character_to_split_on}}" = "${character_to_split_on}" ]; then
      break
    fi
    split_position=$((${split_position} + 1))
  done

  if [ ${split_position} -gt 0 ]; then
    left_value="${line_to_split:0:${split_position}}"
  else
    left_value=""
  fi
  if [ ${split_position} -lt $((${#line_to_split} + ${#character_to_split_on})) ]; then
    right_value="${line_to_split:${split_position} + ${#character_to_split_on}}"
  else
    right_value=""
  fi

  set_param_value "${left_side_var}" "${left_value}"
  set_param_value "${right_side_var}" "${right_value}"
}

function split_feature_file_name
{
  # This function splits a feature file name into two halves:  The folder to run the tests in
  # and the path to the file to be run.
  #
  # PARAMETERS:
  #   ${1}  - feature_file_name_to_split    - The feature file path to split
  #   ${2}  - working_directory_return_var  - The variable to return the folder name in
  #   ${3}  - feature_name_var              - The variable to return the feature file name in

  feature_file_name_to_split="${1}"
  working_directory_return_var="${2}"
  feature_name_var="${3}"

  if [ "${#feature_file_name_to_split}" -gt 2 ]; then
    if [ "${feature_file_name_to_split:0:2}" = "./" ]; then
      feature_file_name_to_split="${feature_file_name_to_split:2}"
    fi
  fi

  split_line_on_char "${feature_file_name_to_split}" "/" work_dir_name feature_path

  set_param_value "${working_directory_return_var}" "${work_dir_name}"
  set_param_value "${feature_name_var}" "${feature_path}"
}

function test_all_features
{
  # This function tests are features available
  #
  # PARAMETERS:
  #   ${1}  - all_features_log_file           - The log file to output to.
  #   ${2}  - all_features_return_var         - Returns the success of the tests.
  #   ${3}  - all_features_failed_folders     - Returns the folders of the failed tests.
  #   ${4}  - all_features_failed_lines       - Returns the lines of the failed tests.
  #   ${5}  - all_features_rspec_failed_lines - Returns the lines of the failed tests.
  #   ${6}  - all_features_failed_results     - Returns the success of the retest of the failed lines.
  #   ${7}  - all_features_missing_steps_var  - The array variable to return the missing steps in.

  cd ${build_base_directory}

  all_features_log_file="${1}"
  all_features_return_var="${2}"
  all_features_failed_folders="${3}"
  all_features_failed_lines="${4}"
  all_features_rspec_failed_lines="${5}"
  all_features_failed_results="${6}"
  all_features_missing_steps_var="${7}"

  test_all_features_files="$(find . -name *.feature)"
  last_build_folder=""
  all_features_test_success="true"

  if [ ! -z "${test_all_features_files}" ]; then
    while read feature_file_name; do
      split_feature_file_name "${feature_file_name}" feature_folder_name feature_file_path
      if [ "${last_build_folder}" != "${feature_folder_name}" ]; then
        build_sub_folder ${build_base_directory} ${feature_folder_name} "test" "false" "false" "${all_features_log_file}"
        last_build_folder="${feature_folder_name}"
      fi

      test_feature "${feature_folder_name}" "${feature_file_path}" "${all_features_log_file}" all_features_single_success "${all_features_failed_folders}" "${all_features_failed_lines}" "${all_features_rspec_failed_lines}" "${all_features_failed_results}" "${all_features_missing_steps_var}"
      if [ "${all_features_single_success}" = "false" ]; then
        all_features_test_success="false"
      fi

      # # If the test failed, exit.
      # if [ "${all_features_test_success}" = "false" ]; then
      #   break
      # fi
    done <<< "${test_all_features_files}"
  fi

  set_param_value "${all_features_return_var}" "${all_features_test_success}"
}

function test_all_rspecs
{
  # This function tests are rspecs available
  #
  # PARAMETERS:
  #   ${1}  - all_rspec_log_file          - The log file to output to.
  #   ${2}  - all_rspec_return_var        - Returns the success of the tests.
  #   ${3}  - all_rspec_failed_lines_var  - Returns the failed lines of the test/s

  cd ${build_base_directory}

  all_rspec_log_file="${1}"
  all_rspec_return_var="${2}"
  all_rspec_failed_lines_var="${3}"

  all_rspec_test_success="true"

  test_rspec "." "" "false" "${all_rspec_log_file}" single_rspec_success "${all_rspec_failed_lines_var}"
  if [ "${single_rspec_success}" = "false" ]; then
    all_rspec_test_success="false"
  fi

  for directory_name in *; do
    if [ -d ${directory_name} ]; then
      test_rspec "${directory_name}" "" "false" "${all_rspec_log_file}" single_rspec_success "${all_rspec_failed_lines_var}"
      if [ "${single_rspec_success}" = "false" ]; then
        all_rspec_test_success="false"
      fi
    fi
  done

  set_param_value "${all_rspec_return_var}" "${all_rspec_test_success}"
}

function test_project
{
  # This function runs all of the rspec tests that it can find to run.
  #
  # PARAMETERS:
  #   ${1}  - test_project_test_success_var       - The variable to return the test success in
  #   ${2}  - test_project_failed_folders_var     - The variable to return the failed folders in
  #   ${3}  - test_project_failed_lines_var       - The variable to return the failed lines in
  #   #{4}  - test_project_retest_results_var     - The variable to return the retest results in
  #   ${5}  - test_project_failed_rspec_lines_var - The variable to return the failed rspec lines in
  #   ${6}  - test_project_missing_steps_var      - The array variable to return the missing steps in

  cd ${build_base_directory}

  test_project_test_success_var="${1}"
  test_project_failed_folders_var="${2}"
  test_project_failed_lines_var="${3}"
  test_project_retest_results_var="${4}"
  test_project_failed_rspec_lines_var="${5}"
  test_project_missing_steps_var="${6}"

  record_branch recorded_name
  backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"

  test_project_rspec_failed_lines=""
  test_project_test_success="true"

  test_all_rspecs "${build_log_directory}/test_run.txt" test_project_single_success "${test_project_failed_rspec_lines_var}"
  if [ "${test_project_single_success}" = "false" ]; then
    test_project_test_success="false"
  fi

  cd ${build_base_directory}

  smoke_project_list=$(find . -name ci.rake)
  if [ ! -z "${smoke_project_list}" ]; then
    while read smoke_project_folder; do
      split_line_on_char "${smoke_project_folder}" "/" smoke_base_folder smoke_project_folder # remove the . directory.
      split_line_on_char "${smoke_project_folder}" "/" smoke_base_folder smoke_project_folder
      if [ -d ${smoke_base_folder} ]; then
        build_sub_folder ${build_base_directory} "${smoke_base_folder}" "test" "false" "false" "${build_log_directory}/test_run.txt"
        test_smoke "${smoke_base_folder}" "ci:smoke" "${build_log_directory}/test_run.txt" test_project_single_success "${test_project_failed_folders_var}" "${test_project_failed_lines_var}" "${test_project_failed_rspec_lines_var}" "${test_project_retest_results_var}" "${test_project_missing_steps_var}"
        if [ "${test_project_single_success}" = "false" ]; then
          test_project_test_success="false"
        fi
      fi
    done <<< "${smoke_project_list}"
  fi

  set_param_value "${test_project_test_success_var}" "${test_project_test_success}"
}

function will_feature_tests_run
{
  # This function sees if something is running on port 3000 which will block the tests
  # from running properly.
  #
  # PARAMETERS:
  #   ${1}  - will_run_folder - The folder to check to see if the tests will run.
  #   ${2}  - will_run_var    - The variable to return if the feature tests can be run.

  will_run_folder="${1}"
  will_run_var="${2}"

  port_not_in_use="true"

  if [ port_not_in_use = "true" ]; then
    conflicting_process_id=""
    set +e
    conflicting_process_id="$(lsof -i -n -P | grep "TCP \*:3000")"
    set -e

    if [ ! -z "${conflicting_process_id}" ]; then
      split_line_on_char "${conflicting_process_id}" " " conflicting_process_name conflicting_process_id
      ltrim_line "${conflicting_process_id}" conflicting_process_id
      split_line_on_char "${conflicting_process_id}" " " conflicting_process_id conflict_ignore_value
      port_not_in_use="false"

      if [ "${conflicting_process_name}" = "ruby" ]; then
        yes_no_prompt "Something is running on port 3000 (${conflicting_process_name} - PID: ${conflicting_process_id})  Feature tests will not run until this is resolved.${return_line}${return_line}Do you want to try to kill the process that is using that port and continue with the test? (y/n): " "y" kill_conflicting_process
        if [ "${kill_conflicting_process}" = "y" ]; then
          set +e
          kill ${conflicting_process_id}
          set -e
          sleep 1

          will_feature_tests_run "${will_run_folder}" "${will_run_var}"
          eval "port_not_in_use=\"\${${will_run_var}}\""
        fi
      else
        format_line "Something is running on port 3000 (${conflicting_process_name} - PID: ${conflicting_process_id})  Feature tests will not run until this is resolved." "" conflict_format_line
        echo "${conflict_format_line}"
      fi
    fi
  fi

  set_param_value "${will_run_var}" "${port_not_in_use}"
}

function show_test_menu
{
  cd ${build_base_directory}

  declare -a test_menu_options
  declare -a file_name_list
  declare -a test_type_list
  declare -a sub_file_list

  test_menu_list_index=0

  initial_prompt="${return_line}The following test runs are available:"

  # 0
  format_line_for_menu "${test_menu_list_index}" "" "Full Tests:  All RSPEC and CI:Smoke" test_menu_line
  test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
  file_name_list[${#file_name_list[@]}]=""
  sub_file_list[${#sub_file_list[@]}]=""
  test_type_list[${#test_type_list[@]}]="full"
  test_menu_list_index=$((${test_menu_list_index} + 1))

  test_smoke_list=$(find . -name ci.rake)
  if [ ! -z "${test_smoke_list}" ]; then
    while read test_smoke_folder; do
      if [ ! -z "${test_smoke_folder}" ]; then
        split_line_on_char "${test_smoke_folder}" "/" test_smoke_base_folder test_smoke_folder # remove the . directory.
        split_line_on_char "${test_smoke_folder}" "/" test_smoke_base_folder test_smoke_folder
        if [ -d ${test_smoke_base_folder} ]; then
          # 1
          format_line_for_menu "${test_menu_list_index}" "" "CI:Smoke - ${test_smoke_base_folder}" test_menu_line
          test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
          file_name_list[${#file_name_list[@]}]="${test_smoke_base_folder}"
          sub_file_list[${#sub_file_list[@]}]=""
          test_type_list[${#test_type_list[@]}]="ci smoke"
          test_menu_list_index=$((${test_menu_list_index} + 1))

          # 2
          format_line_for_menu "${test_menu_list_index}" "" "cucumber:all - ${test_smoke_base_folder}" test_menu_line
          test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
          file_name_list[${#file_name_list[@]}]="${test_smoke_base_folder}"
          sub_file_list[${#sub_file_list[@]}]=""
          test_type_list[${#test_type_list[@]}]="ci cucumber"
          test_menu_list_index=$((${test_menu_list_index} + 1))
        fi
      fi
    done <<< "${test_smoke_list}"
  fi

  # Guard
  test_folders_list="$(find . -name Guardfile)"
  if [ ! -z "${test_folders_list}" ]; then
    test_menu_options[${#test_menu_options[@]}]=""
    format_line "Guard:" "" test_menu_line
    test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"

    while read sub_menu_line_read; do
      # 2 + ${guard_index}
      if [ "${sub_menu_line_read}" != "./Guardfile" ]; then
        submenu_line_value="${sub_menu_line_read:2:${#sub_menu_line_read} - 10 - 2}"
      else
        submenu_line_value="."
      fi
      format_line_for_menu "${test_menu_list_index}" "" "${submenu_line_value}" test_menu_line
      file_name_list[${#file_name_list[@]}]="${submenu_line_value}"
      test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
      sub_file_list[${#sub_file_list[@]}]=""
      test_type_list[${#test_type_list[@]}]="guard"
      test_menu_list_index=$((${test_menu_list_index} + 1))
    done <<< "${test_folders_list}"
  fi

  # RSPEC
  test_folders_list="$(find . -name spec)"
  if [ ! -z "${test_folders_list}" ]; then
    test_menu_options[${#test_menu_options[@]}]=""
    format_line "RSPEC:" "" test_menu_line
    test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"

    # 2 + ${num_guard_tests}
    format_line_for_menu "${test_menu_list_index}" "" "All RSPEC tests" test_menu_line
    test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
    file_name_list[${#file_name_list[@]}]=""
    sub_file_list[${#sub_file_list[@]}]=""
    test_type_list[${#test_type_list[@]}]="rspec"
    test_menu_list_index=$((${test_menu_list_index} + 1))

    while read sub_menu_line_read; do
      # 3 + ${num_guard_tests} + ${rspec_index}
      if [ "${sub_menu_line_read}" != "./spec" ]; then
        submenu_line_value="${sub_menu_line_read:2:${#sub_menu_line_read} - 5 - 2}"
      else
        submenu_line_value="."
      fi
      format_line_for_menu "${test_menu_list_index}" "" "  ${submenu_line_value}" test_menu_line
      file_name_list[${#file_name_list[@]}]="${submenu_line_value}"

      test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
      sub_file_list[${#sub_file_list[@]}]=""
      test_type_list[${#test_type_list[@]}]="rspec"
      test_menu_list_index=$((${test_menu_list_index} + 1))

      cd ${submenu_line_value}/spec

      rspec_files=""
      set +e
      rspec_files="$(find . | grep "_spec.rb$")"
      set -e
      if [ ! -z "${rspec_files}" ]; then
        while read rspec_file_name; do
          format_line_with_prefix "          " "${rspec_file_name:2:${#rspec_file_name} - 2}" "          " test_menu_line
          format_line_for_menu "${test_menu_list_index}" "" "${test_menu_line:6}" test_menu_line
          test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
          file_name_list[${#file_name_list[@]}]="${submenu_line_value}"
          sub_file_list[${#sub_file_list[@]}]="${rspec_file_name:2:${#rspec_file_name} - 2}"
          test_type_list[${#test_type_list[@]}]="rspec"
          test_menu_list_index=$((${test_menu_list_index} + 1))
        done <<< "${rspec_files}"
      fi
      cd ../..
    done <<< "${test_folders_list}"
  fi

  # Features
  test_folders_list="$(find . -name *.feature)"
  if [ ! -z "${test_folders_list}" ]; then
    test_menu_options[${#test_menu_options[@]}]=""
    format_line "Feature Tests:" "" test_menu_line
    test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"

    # 3 + ${num_guard_tests} + ${num_rspec_tests}
    format_line_for_menu "${test_menu_list_index}" "" "All feature tests (one file at a time...)" test_menu_line
    test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
    file_name_list[${#file_name_list[@]}]=""
    sub_file_list[${#sub_file_list[@]}]=""
    test_type_list[${#test_type_list[@]}]="feature"
    test_menu_list_index=$((${test_menu_list_index} + 1))

    while read sub_menu_line_read; do
      # 5 + ${num_guard_tests} + ${num_rspec_tests} + ${feature_index}
      format_line_with_prefix "          " "${sub_menu_line_read:2:${#sub_menu_line_read} - 2}" "          " test_menu_line
      format_line_for_menu "${test_menu_list_index}" "" "${test_menu_line:6}" test_menu_line
      # format_line_for_menu "${test_menu_list_index}" "" "  ${sub_menu_line_read:2:${#sub_menu_line_read} - 2}" test_menu_line
      test_menu_options[${#test_menu_options[@]}]="${test_menu_line}"
      split_feature_file_name "${file_name_list[${selected_test_number}]}" test_feature_folder_name test_feature_file_path
      file_name_list[${#file_name_list[@]}]="${test_feature_file_path}"
      sub_file_list[${#sub_file_list[@]}]="${test_feature_folder_name}"
      test_type_list[${#test_type_list[@]}]="feature"
      test_menu_list_index=$((${test_menu_list_index} + 1))
    done <<< "${test_folders_list}"
  fi

  test_menu_options[${#test_menu_options[@]}]=""
  test_menu_list_index=$((${test_menu_list_index} - 1))

  if [ ! -z "${test_param_test_number}" ]; then
    validate_prompt_value "${test_menu_list_index}" "" "false" "" "${test_param_test_number}" validated_param_value
    test_param_test_number="${validated_param_value}"
  fi
  if [ ! -z "${test_param_test_line}" ]; then
    validate_prompt_value "999999999" "" "false" "" "${test_param_test_line}" validated_param_value
    test_param_test_line="${validated_param_value}"
  fi

  if [ -z "${test_param_test_number}" ]; then
    present_menu test_menu_options[@] "false" "0" "${initial_prompt}" "Please select which test(s) you want to run: " selected_test_number "true" "${test_menu_list_index}"
  else
    selected_test_number="${test_param_test_number}"
  fi
  if [ ! -z "${test_param_test_line}" ]; then
    selected_test_line=":${test_param_test_line}"
  else
    selected_test_line=""
  fi

  declare -a test_menu_missing_steps
  declare -a test_menu_failed_folders
  declare -a test_menu_failed_lines
  declare -a test_menu_failed_rspec_lines
  declare -a test_menu_failed_status
  test_menu_success="true"
  show_test_results="true"

  case "${test_type_list[${selected_test_number}]}" in
    # (
    "full" )
      backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
      test_project test_menu_success test_menu_failed_folders test_menu_failed_lines test_menu_failed_status test_menu_failed_rspec_lines test_menu_missing_steps
      ;;

    # (
    "ci smoke" )
      backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
      build_sub_folder ${build_base_directory} "${file_name_list[${selected_test_number}]}" "test" "false" "false" "${build_log_directory}/test_run.txt"
      run_smoke_test "ci:smoke" "${file_name_list[${selected_test_number}]}" test_menu_success test_menu_failed_folders test_menu_failed_lines test_menu_failed_rspec_lines test_menu_failed_status test_menu_missing_steps
      ;;

    # (
    "ci cucumber" )
      backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
      build_sub_folder ${build_base_directory} "${file_name_list[${selected_test_number}]}" "test" "false" "false" "${build_log_directory}/test_run.txt"
      run_smoke_test "cucumber:all" "${file_name_list[${selected_test_number}]}" test_menu_success test_menu_failed_folders test_menu_failed_lines test_menu_failed_rspec_lines test_menu_failed_status test_menu_missing_steps
      ;;

    # (
    "guard" )
      start_guard "${file_name_list[${selected_test_number}]}"
      show_test_results="false"
      ;;

    # (
    "rspec" )
      backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
      if [ -z "${file_name_list[${selected_test_number}]}" ]; then
        test_all_rspecs "${build_log_directory}/test_run.txt" test_menu_success test_menu_failed_rspec_lines
      else
        test_rspec "${file_name_list[${selected_test_number}]}" "${sub_file_list[${selected_test_number}]}${selected_test_line}" "true" "${build_log_directory}/test_run.txt" test_menu_success test_menu_failed_rspec_lines
      fi
      ;;

    # (
    "feature" )
      backup_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
      if [ -z "${file_name_list[${selected_test_number}]}" ]; then
        test_all_features "${build_log_directory}/test_run.txt" test_menu_success test_menu_failed_folders test_menu_failed_lines test_menu_failed_rspec_lines test_menu_failed_status test_menu_missing_steps
      else
        build_sub_folder ${build_base_directory} ${sub_file_list[${selected_test_number}]} "test" "false" "false" "${build_log_directory}/test_run.txt"
        test_feature "${sub_file_list[${selected_test_number}]}" "${file_name_list[${selected_test_number}]}${selected_test_line}" "${build_log_directory}/test_run.txt" test_menu_success test_menu_failed_folders test_menu_failed_lines test_menu_failed_rspec_lines test_menu_failed_status test_menu_missing_steps
      fi
      ;;
  esac

  if [ "${show_test_results}" = "true" ]; then
    report_test_success "${build_log_directory}/test_run.txt" "${test_menu_success}" test_menu_failed_folders[@] test_menu_failed_lines[@] test_menu_failed_status[@] test_menu_failed_rspec_lines[@] test_type_list[@] file_name_list[@] sub_file_list[@] test_menu_missing_steps[@]
  fi
}

function launch_rails_console
{
  # This function launches the rails console in the host directory.
  record_branch recorded_name
  cd ${build_base_directory}/${project_app_directory}/

  bundle exec rails console
}

function initialize_branch_information
{
  # This function fills in the list of branches and sets a variable to
  # the index of the current branch.
  #  -1 == master
  #  0-#branches == branch
  #
  #   ${1}  - get_local   - if true, gets local branches
  #   ${2}  - get_remotes - if true, gets remote branches
  #   ${3}  - pull_first  - if true, does a pull first to get all remote branches

  func_current_dir="$(pwd)"

  get_local="${1}"
  get_remotes="${2}"
  pull_first="${3}"

  if [ "${get_remotes}" != "true" ]; then
    get_local="true"
  fi

  cd ${build_base_directory}

  # It may be that we are to do a pull first so that we have a full
  # list of remote branches available.
  if [ "${pull_first}" = "true" ]; then
    execute_command "git fetch -p" "" "" ""
  fi

  # Depending on the parameters, get all branches or just local branches.
  git_params=""
  if [ "${get_local}" = "true" ]; then
    if [ "${get_remotes}" = "true" ]; then
      git_params=" -a"
    fi
  else
    git_params=" -r"
  fi

  # Get the list of branches.
  local_branch_list="$(git branch${git_params})"
  # Remove master
  set +e
  local_branch_list="$(echo "${local_branch_list}" | grep -v "^[   ]*\*\?[   ]*master$")"
  set -e
  # Remove origin/master
  local_branch_list="$(echo "${local_branch_list}" | grep -v "origin/HEAD")"
  local_branch_list="$(echo "${local_branch_list}" | grep -v "origin/master")"

  # Unset the list of branches.
  unset branches

  # Read the list of branches into the array.
  if [ "${get_local}" = "true" ]; then
    local_branch=-1
  fi
  branch_count=0
  while read read_branch_name; do
    # Remove the * for the current branch, and save the current branch index.
    if [ "${read_branch_name:0:1}" = "*" ]; then
      read_branch_name=${read_branch_name:2}
      if [ "${get_local}" = "true" ]; then
        local_branch="${branch_count}"
      fi
    fi
    # Remove "remotes/" from the start of the branch
    if [ "${#read_branch_name}" -gt "8" ]; then
      if [ "${read_branch_name:0:8}" = "remotes/" ]; then
        read_branch_name="${read_branch_name:8}"
      fi
    fi

    if [ ! -z "${read_branch_name}" ]; then
      branches[${branch_count}]="${read_branch_name}"
      branch_count=$((${branch_count} + 1))
    fi
  done <<< "${local_branch_list}"

  if [ "${get_local}" = "true" ]; then
    if [ "${local_branch}" -ge "0" ]; then
      local_branch_name="${branches[${local_branch}]}"
    else
      local_branch_name="master"
    fi
  fi

  cd ${func_current_dir}
}

function prompt_branch
{
  # This function will prompt the user to select a branch
  #
  #   ${1}  - show_local      - true if the local branches are to be shown
  #   ${2}  - show_remotes    - true if the remote branches are to be shown
  #   ${3}  - show_master     - true if the master branch is to be shown
  #   ${4}  - show_default    - true if the current branch should be defaulted
  #   ${5}  - initial_prompt  - The text to show at the top of the list
  #   ${6}  - text_prompt     - The prompt text at the bottom of the list
  #   ${7}  - return_index    - The variable to return the selected index in
  #   ${8}  - return_name     - The variable to return the selected name in
  #   ${9}  - prompt_other    - If set, this will provide an extra prompt that
  #                             is not a branch.
  #                             The return_index will be -100.
  #                             The return_name will be the prompt.

  declare -a branch_list_menu

  show_local="${1}"
  show_remotes="${2}"
  show_master="${3}"
  show_default="${4}"
  initial_prompt="${5}"
  text_prompt="${6}"
  return_index="${7}"
  return_name="${8}"
  prompt_other="${9}"

  default_index="-1"

  initialize_branch_information "${show_local}" "${show_remotes}" "${show_remotes}"

  if [ "${show_default}" = "true" ]; then
    default_index=${local_branch}
  fi

  master_shown="false"
  branch_count=0
  if [ "${default_index}" -ge "0" ]; then
    branch_list_menu[${#branch_list_menu[@]}]="${branches[${default_index}]}"
    branch_list_menu[${#branch_list_menu[@]}]=""
    branch_count=$((${branch_count} + 1))
  fi

  if [ "${show_remotes}" = "true" -a "${show_master}" = "true" ]; then
    master_shown="true"
    branch_list_menu[${#branch_list_menu[@]}]="origin/master"
    branch_count=$((${branch_count} + 1))
  fi

  if [ "${show_local}" = "true" -a "${show_master}" = "true" ]; then
    master_shown="true"
    branch_list_menu[${#branch_list_menu[@]}]="master"
    branch_count=$((${branch_count} + 1))
  fi

  if [ "${master_shown}" = "true" ]; then
    branch_list_menu[${#branch_list_menu[@]}]=""
  fi

  master_shown="false"
  branch_offset="${branch_count}"
  while [ "${branch_count}" -lt "$((${#branches[@]} + ${branch_offset}))" ]; do
    if [ "${master_shown}" = "false" -a "${show_local}" = "true" -a "${show_remotes}" = "true" -a ${#branches[${branch_count} - ${branch_offset}]} -gt 7 -a "${branches[${branch_count} - ${branch_offset}]:0:7}" = "origin/" ]; then
      branch_list_menu[${#branch_list_menu[@]}]=""
      master_shown="true"
    fi

    branch_list_menu[${#branch_list_menu[@]}]="${branches[${branch_count} - ${branch_offset}]}"
    branch_count=$((${branch_count} + 1))
  done
  if [ ! -z "${prompt_other}" ]; then
    branch_list_menu[${#branch_list_menu[@]}]=""
    branch_list_menu[${#branch_list_menu[@]}]="${prompt_other}"
    branch_count=$((${branch_count} + 1))
  fi

  # Pick a branch...
  return_branch_index=-3
  return_branch_name=""
  while [ "${return_branch_index}" -lt "-2" -a "${return_branch_index}" -gt "-100" ]; do
    present_menu branch_list_menu[@] "false" "0" "${initial_prompt}" "${text_prompt}" validated_branch_index "false" "0"
    if [ -z "${validated_branch_index}" ]; then
      #invalid entry...
      return_branch_index=-3
    else
      if [ "${validated_branch_index}" = "0" ]; then
        # Pick the default
        return_branch_index=0
        if [ "${show_local}" = "true" -a "${show_master}" = "true" ]; then
          return_branch_index=-1
        fi
        if [ "${show_remotes}" = "true" -a "${show_master}" = "true" ]; then
          return_branch_index=-2
        fi
        if [ "${default_index}" -ge "0" ]; then
          return_branch_index="${default_index}"
        fi
      else
        return_branch_index=$((${validated_branch_index} - ${branch_offset}))
        if [ ${return_branch_index} -eq ${#branches[@]} ]; then
          return_branch_index=-100
          return_branch_name="${prompt_other}"
        fi
      fi
    fi
  done

  # Format the branch name from the index
  if [ "${return_branch_index}" -ge "-2" ]; then
    if [ "${return_branch_index}" = "-2" ]; then
      return_branch_name="origin/master"
    else
      if [ "${return_branch_index}" = "-1" ]; then
        return_branch_name="master"
      else
        return_branch_name="${branches[${return_branch_index}]}"
      fi
    fi
  fi

  set_param_value "${return_index}" "${return_branch_index}"
  set_param_value "${return_name}" "${return_branch_name}"
}

function checkout_branch
{
  # This function performs the actual actions needed to check out a branch.
  #
  # PARAMETERS:
  #   ${1}  - new_branch_name           - The name of the new local branch.
  #   ${2}  - new_branch_remote_source  - The remote branche to create this
  #                                       branch from.  If blank, origin/master will be used.

  cd ${build_base_directory}

  new_branch_name="${1}"
  new_branch_remote_source="${2}"

  if [ -z "${new_branch_remote_source}" ]; then
    new_branch_remote_source="origin/master"
  fi

  echo "Creating the branch \"${new_branch_name}\" from \"${new_branch_remote_source}\""

  check_branch_for_switch "When creating a new branch, if it is not clean, the created branch will be merged with your changes muddying it before you start.  You should stash or discard your changes before continuing." "" "switch" "false"

  cd ${build_base_directory}

  # I probably don't have to, but if branching, start in master...
  if [ "${local_branch}" != "-1" ]; then
    execute_command "git checkout master" "" "" ""
    set +e
    git checkout master
    set -e

    # Normally when we switch, we restore the branches stash, but that is not what we
    # want to always do, so we don't.
  fi

  # Do the branch
  record_history "  # Create branch: \"${new_branch_name}\" from \"${new_branch_remote_source}\""
  execute_command "git checkout -b ${new_branch_name} ${new_branch_remote_source}" "" "" ""
  if [ ${#new_branch_remote_source} -gt 7 ]; then
    if [ ${new_branch_remote_source:0:7} = "origin/" ]; then
      update_origin_branch "${new_branch_name}" "${new_branch_name}"
    fi
  fi
}

function create_branch_new
{
  # Create a new branch.
  cd ${build_base_directory}

  initialize_branch_information true true true

  branch_name=""
  switch_branch_name=""

  # Get the branch number
  # Get the Version-One story number.
  story_number=""
  while [ -z "${story_number}" ]; do
    # Read the number.
    read -p "Enter the Version-One story number (XXXXX): " story_number
    echo ""
    # validate that the number is valid.
    if ! echo "${story_number}" | grep -q "^[0-9]\{5\}$"; then
      echo "The value \"${story_number}\" is not a properly formatted Version-One story number, please retry."
      story_number=""
    fi
  done
  # Prepend the B- to the story number.
  alt_story_number="B-${story_number}"
  alt2_story_number="B_${story_number}"
  story_number="b${story_number}"

  # Check that the name doesn't already exist.
  branch_count=0
  while [ "${branch_count}" -lt "${#branches[@]}" ]; do
    if [ "${branches[${branch_count}]:0:${#story_number}}" = "${story_number}" -o "${branches[${branch_count}]:0:7 + ${#story_number}}" = "origin/${story_number}" -o "${branches[${branch_count}]:0:${#alt_story_number}}" = "${alt_story_number}" -o "${branches[${branch_count}]:0:7 + ${#alt_story_number}}" = "origin/${alt_story_number}" -o "${branches[${branch_count}]:0:${#alt2_story_number}}" = "${alt2_story_number}" -o "${branches[${branch_count}]:0:7 + ${#alt2_story_number}}" = "origin/${alt2_story_number}" ]; then
      yes_no_prompt "The branch \"${branches[${branch_count}]}\" already exists for the story \"${story_number}\".  Do you want to use that branch instead of creating a new one? (y/n): " "y" branch_from_branch
      if [ "${branch_from_branch}" = "y" ]; then
        branch_name="${branches[${branch_count}]}"
        switch_branch_name="${branches[${branch_count}]}"
      fi
      break
    fi

    branch_count=$((${branch_count} + 1))
  done

  # If there isn't a branch we want to switch to, then create it.
  if [ -z "${switch_branch_name}" ]; then
    # Get a name for the branch.
    while [ -z "${branch_name}" ]; do
      story_name=""
      while [ -z "${story_name}" ]; do
        read -p "Enter a short description for story ${story_number}: " story_name
        echo ""
        # Validate the name.
        if [ "${#story_name}" -gt "30" ]; then
          echo "The description \"${story_name}\" is too long, pleae enter a shorter description."
          story_name=""
        fi
      done
      # Replace spaces with -'s so I can be lazy with naming the branch...
      story_name="${story_name//\ /_}"
      branch_name="${story_number}_${story_name}"
    done

    prompt_branch true true true false "Avalable branches:" "Enter which branch to create the branch \"${branch_name}\" from: " selected_branch source_branch
    checkout_branch "${branch_name}" "${source_branch}"
  else
    # Create a local copy of the branch, or switch to the branch.
    if [ "${#switch_branch_name}" -gt 7 ]; then
      if [  "${switch_branch_name:0:7}" = "origin/" ]; then
        checkout_branch "${switch_branch_name:7}" "${switch_branch_name}"
      else
        # Just switch to the branch...
        switch_to_branch "${switch_branch_name}"
      fi
    else
      # Just switch to the branch...
      switch_to_branch "${switch_branch_name}"
    fi
  fi
}

function create_branch
{
  # This function will create a branch for you.
  # If the branch is local, it will ask for the story number and a name to use.

  yes_no_prompt "Do you want to create a local version of an existing branch in git-hub (y/n): " "y" branch_from_branch

  if [ "${branch_from_branch}" = "y" ]; then
    create_branch_existing
  else
    create_branch_new
  fi
}

function create_branch_existing
{
  # Create a branch from an existing remote branch
  cd ${build_base_directory}

  local_name=""
  while [ -z "${local_name}" ]; do
    # prompt what remote branch to create locally
    prompt_branch false true false false "Select the remote branch that you want to create locally:" "Type the number of the branch to use: " selected_branch selected_branch_name

    # Remove /origin from the name...
    if [ "${#selected_branch_name}" -gt 7 ]; then
      if [ "${selected_branch_name:0:7}" = "origin/" ]; then
        local_name="${selected_branch_name:7}"

        if [ "${local_name}" = "master" ]; then
          echo "The branch name \"${local_name}\" already exists.  Please select a different branch name."
          local_name=""
        fi

        initialize_branch_information true false false
        branch_count=0
        while [ "${branch_count}" -lt "${#branches[@]}" ]; do
          if [ "${branches[${branch_count}]}" = "${local_name}" ]; then
            echo "The branch name \"${local_name}\" already exists.  Please select a different branch name."
            local_name=""
            break
          fi

          branch_count=$((${branch_count} + 1))
        done
      fi
    fi
  done

  checkout_branch "${local_name}" "${selected_branch_name}"
}

function check_for_push
{
  # This function checks to see if it is safe to do a push.  This check will include
  # checking to see if a merge has been done and if there are any potential
  # gotchas in the merge.
  #
  # PARAMETERS:
  #   ${1}  - check_push_branch_name        - The name of the branch we are checking
  #   ${2}  - check_push_continue_push_var  - The variable to return wether or not to continue the push

  check_push_branch_name="${1}"
  check_push_safe_to_push_var="${2}"

  check_continue_push="true"
  validate_merge_conflicts check_continue_push

  if [ ${check_continue_push} = "true" ]; then
    # quit the running verion of gitx
    # osascript -e 'tell application "GitX" to quit'
    # open gitx and wait till it is done
    # open -W -a gitx

    check_push_changes="$(git status --porcelain)"
    if [ ! -z "${check_push_changes}" ]; then
      # open gitx to make sure that everything is committed...
      set +e
      gitx
      set -e
    fi

    # Wait for the user to commit using gitx...
    if [ ! -z "${check_push_changes}" ]; then
      yes_no_prompt "The branch \"${check_push_branch_name}\" contains uncommitted files.  Do you want to push with these files still uncommitted? (y/n): " "y" check_continue_push
    else
      check_continue_push="y"
    fi

    if [ "${check_continue_push}" = "y" ]; then
      check_continue_push="true"
    else
      check_continue_push="false"
    fi
  fi

  set_param_value "${check_push_safe_to_push_var}" "${check_continue_push}"
}

function push_source
{
  # Push a branch to GitHub...
  cd ${build_base_directory}

  # Check what branch to push.
  # The default is the current branch (if it is not master)
  prompt_branch true false false true "Multiple branches were identified.  The following branches are available for you to push:" "Type the number of the branch to check in: " selected_branch selected_branch_name

  # Do the push...
  if [ "${selected_branch}" -ge "0" ]; then
    # Double check...
    yes_no_prompt "Are you sure you want to push the branch \"${selected_branch_name}\" (y/n): " "y" continue_push
    if [ "${continue_push}" = "y" ]; then
      cd ${build_base_directory}
      if [ "${selected_branch}" != "${local_branch}" ]; then
        check_branch_for_switch "" "" "switch" "false"
        switch_to_branch "${selected_branch_name}"
      fi

      check_for_push "${selected_branch_name}" continue_push

      if [ "${continue_push}" = "true" ]; then
        get_origin_branch "${selected_branch_name}" "push" "true" remote_branch_name

        # push
        record_history "  # Pushing ${remote_branch_name}"
        execute_command "git push origin ${remote_branch_name}" "" "" ""
        update_origin_branch "${selected_branch_name}" "${remote_branch_name}"
      fi
    fi
  else
    echo "You are using the master branch, and pushing the master branch is not permitted."
  fi
}

function merge_branch
{
  # This function will merge two branches.  First you select the destination
  # branch to merge into, then the branch to merge into it.
  cd ${build_base_directory}
  prompt_branch true false true true "Which branch do you want to merge into?" "Type the number of the branch to merge into: " selected_branch merge_dest_name

  merge_source_branch=-3
  merge_source_name=""
  while [ "${merge_source_branch}" -lt "-2" ]; do
    prompt_branch true true true false "Which branch do you want to merge from?" "Type the number of the branch to merge into \"${merge_dest_name}\": " merge_source_branch merge_source_name

    if [ "${merge_source_branch}" = "${selected_branch}" ]; then
      echo "You cannot merge a branch into itself.  Please select another branch."
      merge_source_branch=-3
    fi
  done

  record_history "  # Merging the branch \"${merge_source_name}\" into the branch \"${merge_dest_name}\""
  echo "Merging the branch \"${merge_source_name}\" into the branch \"${merge_dest_name}\""
  # Switch to the destination branch if we are not already there.
  if [ "${selected_branch}" != "${local_branch}" ]; then
    check_branch_for_switch "" "" "switch" "false"
    switch_to_branch "${merge_dest_name}"
  fi

  # Merge
  merge_message="Automated merge of ${merge_source_name} into ${merge_dest_name} on $(date ${time_format_sting})"
  if [ ${#merge_source_name} -gt 7  ]; then
    if [ "${merge_source_name:0:7}" = "origin/" ]; then
      execute_command "git fetch origin ${merge_source_name:7}" "" "" ""
    fi
  fi

  execute_command "git merge ${merge_source_name} -m \"${merge_message}\"" "" "" ""
}

function check_branch_for_switch
{
  # This function checks a branch to see if it thinks that it is safe to switch
  # to another branch.  If it is possibly unsafe, then the user is prompted with
  # options to stash, reset or ignore to make the switch happen "safely"
  #
  # PARAMETERS:
  #   ${1}  - switch_check_menu_pre_text    - The text to show if there are unsaved changes.
  #   ${2}  - switch_check_prompt           - The text to prompt the user for input.
  #   #{3}  - switch_check_stash_type       - A mini note to indicate the type of stash being performed.
  #   #{4}  - switch_check_include_commits  - True/False if un-pushed changes are to be checked.

  switch_check_menu_pre_text="${1}"
  switch_check_prompt="${2}"
  switch_check_stash_type="${3}"
  switch_check_include_commits="${4}"

  cd ${build_base_directory}

  if [ -z "${switch_check_menu_pre_text}" ]; then
    switch_check_menu_pre_text="There are uncommitted changes in this branch.${return_line}This could cause the switch to fail.  Would you like to:"
  fi
  if [ -z "${switch_check_prompt}" ]; then
    switch_check_prompt="Select the option you would like to do: "
  fi

  declare -a switch_menu_items

  switch_menu_items[${#switch_menu_items[@]}]="Stash changes"
  switch_menu_items[${#switch_menu_items[@]}]="Commit changes"
  switch_menu_items[${#switch_menu_items[@]}]="Hard reset to last checkin"
  switch_menu_items[${#switch_menu_items[@]}]="Ignore and continue (may not switch)"

  prompt_user_for_changes="false"
  if ! git status | tail -n 1 | grep -q "nothing to commit"; then
    prompt_user_for_changes="true"
  fi

  if [ "${switch_check_include_commits}" = "true" ]; then
    # check to see if there are un-pushed commits.
    get_origin_branch "${local_branch_name}" "push" "false" remote_branch_name

    unpushed_commits=""
    set +e
    if [ ! -z "${remote_branch_name}" ]; then
      unpushed_commits="$(git log origin/${remote_branch_name}..HEAD)"
    fi
    set -e
    if [ ! -z "${unpushed_commits}" ]; then
      prompt_user_for_changes="true"
    fi
  fi

  if [ "${prompt_user_for_changes}" = "true" ]; then
    hard_reset_success="false"
    while [ -z "${hard_reset_success}" -o "${hard_reset_success}" = "false" ]; do
      hard_reset_success="true"

      present_menu switch_menu_items[@] "false" "0" "${switch_check_menu_pre_text}" "${switch_check_prompt}" selected_switch_option "false" "0"

      case "${selected_switch_option}" in
        # (
        "0")
        stash_changes "${switch_check_stash_type}" ""
        ;;

        # (
        "1")
        commit_changes
        check_branch_for_switch "${switch_check_menu_pre_text}" "${switch_check_prompt}" "${switch_check_stash_type}" "${switch_check_include_commits}"
        ;;

        # (
        "2")
        hard_reset_repository "true" hard_reset_success
        ;;

        # (
        "3")
        # ignore, and continue...
        ;;
      esac
    done

    echo ""
  fi
}

function switch_to_branch
{
  # This function switches to a branch, and if the switch is successful, prompts you to
  # restore the last stash for this branch that was automatically saved when you
  # switched you of it.
  #
  # PARAMETERS:
  #   ${1}  - switch_to_branch_name
  #   ${2}  - switch_success_var

  switch_to_branch_name="${1}"
  switch_success_var="${2}"

  record_history "  # Switch to branch: ${switch_to_branch_name}"

  performed_switch="true"

  if [ ${#switch_to_branch_name} -gt 7 ]; then
    if [ "${switch_to_branch_name:0:7}" = "origin/" ]; then
      switch_to_branch_name="${switch_to_branch_name:7}"

      record_history "  # Try to switch to local branch: ${switch_to_branch_name}"

      initialize_branch_information "true" "false" "false"
      switch_search_index=0
      while [ ${switch_search_index} -lt ${#branches[@]} ]; do
        if [ "${branches[${switch_search_index}]}" = "${switch_to_branch_name}" ]; then
          break
        fi
        switch_search_index=$((${switch_search_index} + 1))
      done
      if [ ${switch_search_index} -ge ${#branches[@]} ]; then
        performed_switch="false"
      fi
    fi
  fi

  if [ "${performed_switch}" = "true" ]; then
    execute_command "git checkout ${switch_to_branch_name}" "" git_success ""

    if [ "${git_success}" = "0" ]; then
      prompt_apply_stash "switch" switch_applied_stash
      if [ ! -z "${switch_applied_stash}" ]; then
        perform_drop_stash "${switch_applied_stash}" "false"
      fi
    else
      performed_switch="false"

      record_history "  # Switch to branch failed"
      record_branch recorded_name
      echo "Swtich failed!!!"
    fi
  else
    record_history "  # local version of the remote branch doesn't exist."
  fi

  if [ ! -z "${switch_success_var}" ]; then
    set_param_value "${switch_success_var}" "${performed_switch}"
  fi
}

function switch_branch
{
  # This function will switch the current branch
  cd ${build_base_directory}

  prompt_branch true false true true "Which branch do you want to switch to?" "Type the number of the branch to switch to: " selected_branch merge_dest_name "The branch is not listed and is a remote branch that has not been created locally..."

  if [ "${selected_branch}" = "-100" ]; then
    create_branch_existing
  else
    if [ "${selected_branch}" != "${local_branch}" ]; then
      check_branch_for_switch "" "" "switch" "false"
      switch_to_branch "${merge_dest_name}"
    fi
  fi
}

function delete_branch
{
  # This function will try to delete a branch.  The branch can only be deleted if it has been merged to master.
  cd ${build_base_directory}
  prompt_branch true true false true "Which branch do you want to try to delete?" "Type the number of the branch to delete: " selected_branch selected_branch_name

  check_switch_unpushed="true"
  if [ "${selected_branch}" != "${local_branch}" ]; then
    check_branch_for_switch "" "" "switch" "false"
    switch_to_branch "${selected_branch_name}" delete_branch_switch_success
    if [ "${delete_branch_switch_success}" = "false" ]; then
      check_switch_unpushed="false"
    fi
  fi

  # If I am on the branch, or if I switched to the branch successfully...
  if [ "${selected_branch}" = "${local_branch}" -o "${check_switch_unpushed}" = "true" ]; then
    check_branch_for_switch "This branch is not fully merged with master.${return_line}${return_line}If you simply stash your changes, you may still be prompted to do a hard delete of committed but not yet pushed changes.${return_line}Please select from the following options:" "" "delete" "true"
  fi

  # You cannot delete the branch you are in.  Switch to master so we can delete it.
  if [ "${selected_branch}" != "${local_branch}" -o "${local_branch}" != "-1" ]; then
    check_branch_for_switch "" "" "switch" "false"
    switch_to_branch "master"
    # execute_command "git checkout master" "" "" ""
  fi

  if [ ${#selected_branch_name} -gt 7 ]; then
    if [ "${selected_branch_name:0:7}" = "origin/" ]; then
      delete_remote_branch=""
      echo "${return_line}${return_line}"
      yes_no_prompt "Deleting: ${selected_branch_name}${return_line}You have selected a remote branch to delete.  Are you REALLY sure? (y/n): " "" delete_remote_branch

      if [ "${delete_remote_branch}" = "y" ]; then
        echo "Deleting remote branch ${selected_branch_name}."
      else
        exit 4
      fi
    fi
  fi

  record_history "  # Delete branch: ${selected_branch_name}"
  if [ ${#selected_branch_name} -gt 7 -a "${selected_branch_name:0:7}" = "origin/" ]; then
    execute_command "git push origin --delete ${selected_branch_name:7}" "" "" ""
  else
    echo "${return_line}${return_line}"
    yes_no_prompt "Deleting: ${selected_branch_name}${return_line}Are you sure you want to delete this branch? (y/n)" "" delete_remote_branch
    if [ "${delete_remote_branch}" = "y" ]; then
      execute_command "git branch -d ${selected_branch_name}" "" branch_delete_success ""

      if [ "${branch_delete_success}" != "0" ]; then
        echo "${return_line}"
        yes_no_prompt "Failed to delete: ${selected_branch_name}${return_line}Do you want to force a delete and lose your changes? (y/n): " "y" delete_remote_branch
        if [ "${delete_remote_branch}" = "y" ]; then
          record_history "  # Force delete branch: ${selected_branch_name}"
          execute_command "git branch -D ${selected_branch_name}" "" branch_delete_success ""
        fi
      fi

      # If we deleted the branch successfully, then prompt to delete the stashes...
      if [ "${branch_delete_success}" = "0" ]; then
        confirm_delete_stashes=""
        while [ -z "${confirm_delete_stashes}" ]; do
          show_stash_list_menu "The following stashes were made against this branch:" "" "false" delete_stash_sel "" "${selected_branch_name}"
          if [ ! -z "${delete_stash_sel}" ]; then
            yes_no_prompt "Would you like to delete all of these stashes for the branch you just deleted? (y/n): " "" confirm_delete_stashes
          else
            confirm_delete_stashes="x"
          fi
        done
        if [ "${confirm_delete_stashes}" = "y" ]; then
          cd ${build_base_directory}

          declare -a stash_del_list
          while [ ! -z "${delete_stash_sel}" ]; do
            split_line_on_char "${delete_stash_sel}" "${return_line}" stash_to_delete delete_stash_sel
            stash_del_list[${#stash_del_list[@]}]="${stash_to_delete}"
          done
          while [ ${#stash_del_list[@]} -gt 0 ]; do
            execute_command "git stash drop ${stash_del_list[$((${#stash_del_list[@]} - 1))]}" "" "" ""
            unset stash_del_list[$((${#stash_del_list[@]} - 1))]
          done
        fi
      fi
    fi
  fi
}

function start_guard
{
  # This function runs guard in the passed in folder
  #
  # PARAMETERS:
  #   ${1}  - guard_folder_run  - The folder in which to run guard.

  guard_folder_run="${1}"

  cd ${build_base_directory}

  record_history "  # Starting guard in \"${guard_folder_run}\""
  cd ${guard_folder_run}

  execute_command "bundle exec guard" "" "" ""
}

function show_guard_menu
{
  # This function will start guard looking at a directory...
  declare -a guard_folder_list

  cd ${build_base_directory}

  # Let the user select the folder to run Guard in.
  folders_list="$(find . -name Guardfile)"
  validated_branch_index=""

  if [ ! -z "${folders_list}" ]; then
    while read guard_folder; do
      guard_folder_list[${#guard_folder_list[@]}]="${guard_folder:2:${#guard_folder} - 10 - 2}"
    done <<< "${folders_list}"
  fi

  present_menu guard_folder_list[@] "true" "0" "Select which folder to run Guard in:" "Type the number of the folder to run Guard in: " validated_branch_index "false" "0"

  start_guard "${guard_folder_list[${validated_branch_index}]}"
}

function run_site
{
  # This function simply launches the rails thin client.
  # In the future, the system might do something different if the environment
  # is Ubuntu.

  record_branch recorded_name

  cd ${build_base_directory}/${project_app_directory}

  if [ -f config/environments/${rails_env_to_use}.rb ]; then
    # Don't forget that when in production mode, the thin server has to serve the
    # static assets.  (on www, Apache does this for us, so it should stay false when)
    # checked in.
    is_using_ubuntu running_on_ubuntu
    if [ "${rails_env_to_use}" = "production" ]; then
      if [ "${running_on_ubuntu}" = "false" ]; then
        sed -i "" "s/config\.serve_static_assets *=.*/config\.serve_static_assets = true/g" config/environments/${rails_env_to_use}.rb
      fi
    else
      if [ "${running_on_ubuntu}" = "false" ]; then
        sed -i "" "s/config\.serve_static_assets *=.*/config\.serve_static_assets = false/g" config/environments/${rails_env_to_use}.rb
      fi
    fi
  fi

  echo "Starting ${project_base_name}..."
  if grep -qw "thin" Gemfile*; then
    execute_command "RAILS_ENV=${rails_env_to_use} bundle exec rails s thin -p 3005" "" "" ""
  else
    execute_command "RAILS_ENV=${rails_env_to_use} bundle exec rails s -p 3005" "" "" ""
  fi
}

function move_build_base_directory
{
  # Moves the project directory out of the way so you can clone a clean repository.

  if [ -d ${build_base_directory} ]; then
    new_project_name="$(date ${time_format_sting})_${project_base_name}"
    # new_project_name="old_project_$(date ${time_format_sting})"
    record_history "  # Moving ${project_base_name} to ${new_project_name}"
    cd ${build_parent_directory}
    mv ${project_base_name} ${new_project_name}
    record_history "  # Moved ${project_base_name} to ${new_project_name}"
  fi
}

function clone_repository
{
  # This function clones project into the current directory.

  if [ -d ${build_base_directory}/.git ]; then
    echo "The project directory \"${build_base_directory}\" already exists.  Clone aborted."
    exit 3
  fi

  record_history "  # Clone Project"
  cd ${build_parent_directory}
  execute_command "git clone git@github.com:${project_repository_name}/${project_base_name}.git" "" "" ""
}

function deploy_to_production
{
  # This function does a "deployment" to a production system.
  #
  # This basically just means that it does the following using the production
  # environment in the project applications main folder:
  #   bundle install
  #   bundle exec rake db:migrate
  #   bundle exec rake db:seed
  #   bundle exec rake i18n:precompile
  #   bundle exec rake assets:precompile

  record_branch recorded_name

  cd ${build_base_directory}
  backup_outputs "${build_log_directory}" "prod_deploy.txt" "1w" "7 days"

  if [ "${project_app_directory}" != "." ]; then
    if [ -d ${build_base_directory}/${project_app_directory} ]; then
      build_sub_folder ${build_base_directory} "${project_app_directory}" "production" "false" "false" "${build_log_directory}/prod_deploy.txt"
    fi
  fi
}

function deploy_system
{
  # This function deploys the system.

  declare -a deployment_options

  cd ${build_base_directory}

  deployment_menu_selection="-1"

  if [ -f ${build_base_directory}/${project_app_directory}/Capfile ]; then
    deployment_options[${#deployment_options[@]}]="Capestrano"
    deployment_menu_selection="0"
  fi
  if git remote | grep -q "heroku"; then
    deployment_options[${#deployment_options[@]}]="Heroku"
    deployment_menu_selection="1"
  fi

  if [ ${#deployment_options[@]} -gt 1 ]; then
    present_menu deployment_menu_selection[@] "false" "0" "Select the type of deployment to use..." "Select the deployment you want to use: " deployment_menu_selection "false" 0
  fi

  if [ "${deployment_menu_selection}" = "0" ]; then
    deploy_capestrano
  fi

  if [ "${deployment_menu_selection}" = "1" ]; then
    deploy_heroku
  fi
}

function deploy_capestrano
{
  # If the system supports capestrano deployment, it will deploy to capestrano

  # If available, do a capestrano deployment...
  if [ -f ${build_base_directory}/${project_app_directory}/Capfile ]; then
    backup_outputs "${build_log_directory}" "deploy.txt" "1w" "7 days"
    cd ${build_base_directory}

    declare -a deployment_systems

    deploy_list=$(ls ${build_base_directory}/${project_app_directory}/config/deploy)

    while read deploy_type; do
      deploy_type="${deploy_type:0:$((${#deploy_type} - 3))}"
      deployment_systems[${#deployment_systems[@]}]="${deploy_type}"
    done <<< "${deploy_list}"

    prompt_branch false true true true "Which branch do you want to try to deploy?" "Type the number of the branch to be deployed: " selected_branch selected_branch_name
    if [ "${#selected_branch_name}" -gt 7 ]; then
      if [ "${selected_branch_name:0:7}" = "origin/" ]; then
        selected_branch_name="${selected_branch_name:7}"
      fi
    fi
    echo "Deploying the branch: \"${selected_branch_name}\"" 2>&1 | tee -a ${build_log_directory}/deploy.txt
    echo ""

    present_menu deployment_systems[@] "true" "0" "Select which machine to deploy to:" "Type the number of the machine you want to deploy to: " validated_branch_index "false" "0"

    record_history "  # Deploying the branch \"${selected_branch_name}\" to \"${deployment_systems[${validated_branch_index}]}\""
    extra_params="${deployment_systems[${validated_branch_index}]}"
    if [ "${selected_branch_name}" != "origin/master" -a "${selected_branch_name}" != "master" ]; then
      extra_params="${extra_params} -s branch=\"${selected_branch_name}\""
    fi

    cd ${build_base_directory}/${project_app_directory}
    execute_command "bundle exec cap ${extra_params} deploy" "${build_log_directory}/deploy.txt" "" ""
  fi
}

function deploy_heroku
{
  cd ${build_base_directory}
  backup_outputs "${build_log_directory}" "heroku_deploy.txt" "1w" "7 days"
  if git remote | grep -q "heroku"; then
    record_branch deploy_orig_branch_name
    if [ "${deploy_orig_branch_name}" != "master" ]; then
      switch_to_branch "master"
    fi

    yes_no_prompt "Do you want to pull from master before pushing to heroku? (y/n): " "y" pull_before_deploy
    if [ "${pull_before_deploy}" = "y" ]; then
      pull_project_source deploy_pull_heroku_updated
    fi

    execute_command "git push heroku master" "${build_log_directory}/heroku_deploy.txt" "" ""
    if [ -f config/database.yml ]; then
      heroku_run "rake db:migrate" "${build_log_directory}/heroku_deploy.txt"
    fi
    if [ -f config/mongoid.yml ]; then
      heroku_run "rake db:create_indexes" "${build_log_directory}/heroku_deploy.txt"
    fi
    heroku_run "rake db:seed" "${build_log_directory}/heroku_deploy.txt"

    echo "Switching back to branch: \"${deploy_orig_branch_name}\""
    if [ "${deploy_orig_branch_name}" != "master" ]; then
      switch_to_branch "${deploy_orig_branch_name}"
    fi
  fi
}

function stash_lock_files
{
  clear_old_outputs "${build_log_directory}" "Gemfile.lock" "1w" "7 days"

  log_backup_dir="${build_log_directory}/old/Gemfile.lock.$(date ${time_format_sting})"
  cd ${build_base_directory}
  lock_file_list="$(find . -name Gemfile.lock)"
  if [ ! -z "${lock_file_list}" ]; then
    while read lock_file; do
      if [ -e ${lock_file} ]; then
        set +e
        lock_return="$(git ls-files ${lock_file} --error-unmatch 2>&1)"
        lock_exists="${?}"
        set -e

        mkdir -p ${log_backup_dir}/${lock_file}
        rmdir ${log_backup_dir}/${lock_file}
        if [ "${lock_exists}" != "0" ]; then
          execute_command "mv ${lock_file} ${log_backup_dir}/${lock_file}" "" "" ""
        else
          execute_command "cp ${lock_file} ${log_backup_dir}/${lock_file}" "" "" ""
        fi
      fi
    done <<< "${lock_file_list}"
  fi
}

function get_current_status
{
  record_branch recorded_name

  cd ${build_base_directory}
  execute_command "git status" "" ""

  initialize_branch_information true false false

  get_origin_branch "${local_branch_name}" "push" "false" remote_branch_name

  unpushed_commits=""
  set +e
  if [ ! -z "${remote_branch_name}" ]; then
    unpushed_commits="$(git log origin/${remote_branch_name}..HEAD)"
  else
    unpushed_commits="$(git log origin/master..HEAD)"
  fi
  set -e

  echo ""
  echo "Commits which have not been pushed:"
  if [ -z "${remote_branch_name}" ]; then
    if [ -z "${unpushed_commits}" ]; then
      echo "  [00;32mThere are no commits waiting to be pushed...[00m"
    else
      git log origin/master..HEAD
    fi
    echo "[00;31mThere is no remote branch for this branch yet...[00m"
  else
    if [ -z "${unpushed_commits}" ]; then
      echo "  [00;32mThere are no commits waiting to be pushed...[00m"
    else
      git log origin/${remote_branch_name}..HEAD
    fi
  fi
}

function show_history
{
  mkdir -p ${build_log_directory}
  if [ -f ${build_log_directory}/recorded_history.txt ]; then
    echo "Outputting history..."
    execute_command "tail -n 50 ${build_log_directory}/recorded_history.txt" "" "" ""
  fi
}

function clear_log_histories
{
  clear_old_outputs "${build_log_directory}" "git_pull.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "db_reset.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "build_output.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "test_run.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "deploy_output.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "deploy.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "heroku_deploy.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "single_heroku_deploy.txt" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "Gemfile.lock" "1w" "7 days"
  clear_old_outputs "${build_log_directory}" "prod_deploy.txt" "1w" "7 days"
}

function show_stash_list_menu
{
  # This function lists the stashes and prompts the user to select one.
  #
  # PARAMETERS:
  #   ${1}  - stash_pre_text      - The text to show before the stash list.
  #   ${2}  - stash_prompt        - The prompt to show
  #   ${3}  - stash_show_default  - true/false to show the default/most recent stash
  #   ${4}  - sel_stash_var       - The variable to return the stash index in.
  #   ${5}  - prompt_search_text  - If a stash with this text for this branch does
  #                                 not exist, do not prompt.
  #   ${6}  - stash_branch_filter - The branch to filter the list to

  stash_pre_text="${1}"
  stash_prompt="${2}"
  stash_show_default="${3}"
  sel_stash_var="${4}"
  prompt_search_text="${5}"
  stash_branch_filter="${6}"

  cd ${build_base_directory}

  record_branch recorded_name

  declare -a stash_list
  declare -a stash_line_list_1
  declare -a stash_line_list_2
  declare -a stash_line_list_3
  declare -a stash_line_list_4
  declare -a stash_line_list_branch
  declare -a branch_list
  declare -a branch_stashes
  declare -a list_stash_index
  declare -a set_stash_lines

  # Stash lines:
  #   <comment>
  #   Type: <type>
  #   Date: <date>
  #   <auto-comment>
  #   Branch: <branch>

  branch_list[0]="${recorded_name}"
  base_stash_branch_index=-1

  if [ ! -z "${stash_branch_filter}" ]; then
    branch_list[0]="${stash_branch_filter}"
  fi

  selected_list_value=""
  stashed_items="$(git stash list)"
  found_stash="false"
  found_stash_index=""
  while read stash_line; do
    if [ ! -z "${stash_line}" ]; then
      stash_start=0
      while [ ${stash_start} -lt ${#stash_line} ]; do
        if [ "${stash_line:${stash_start}:1}" = ":" ]; then
          break
        fi
        stash_start=$((${stash_start} + 1))
      done
      stash_index=${#stash_list[@]}
      stash_list[${stash_index}]="${stash_line:0:${stash_start}}"

      stash_start=$((${stash_start} + 1))
      while [ ${stash_start} -lt ${#stash_line} ]; do
        if [ "${stash_line:${stash_start}:1}" != " " ]; then
          break
        fi
        stash_start=$((${stash_start} + 1))
      done
      stash_end=${stash_start}
      while [ ${stash_end} -lt $((${#stash_line} - 1)) ]; do
        if [ "${stash_line:${stash_end}:2}" = "on" ]; then
          break
        else
          if [ "${stash_line:${stash_end}:2}" = "On" ]; then
            break
          fi
        fi
        stash_end=$((${stash_end} + 1))
      done
      stash_end=$((${stash_end} + 2))
      while [ ${stash_start} -lt ${#stash_line} ]; do
        if [ "${stash_line:${stash_end}:1}" != " " ]; then
          break
        fi
        stash_end=$((${stash_end} + 1))
      done
      stash_middle=${stash_end}
      while [ ${stash_end} -lt ${#stash_line} ]; do
        if [ "${stash_line:${stash_end}:1}" = ":" ]; then
          break
        fi
        stash_end=$((${stash_end} + 1))
      done
      branch_name=${stash_line:${stash_middle}:${stash_end} - ${stash_middle}}
      stash_middle=${stash_end}
      stash_end=$((${stash_end} + 1))
      while [ ${stash_end} -lt ${#stash_line} ]; do
        if [ "${stash_line:${stash_end}:1}" != " " ]; then
          break
        fi
        stash_end=$((${stash_end} + 1))
      done

      stash_show_branch="true"
      if [ ! -z "${stash_branch_filter}" ]; then
        if [ "${stash_branch_filter}" != "${branch_name}" ]; then
          stash_show_branch="false"
        fi
      fi

      if [ "${stash_show_branch}" = "true" ]; then
        branch_index=0
        while [ ${branch_index} -lt ${#branch_list[@]} -a "${branch_list[${branch_index}]}" != "${branch_name}" ]; do
          branch_index=$((${branch_index} + 1))
        done
        if [ ${branch_index} -ge ${#branch_list[@]} ]; then
          branch_list[${branch_index}]="${branch_name}"
        fi
        if [ "${stash_index}" = "0" ]; then
          base_stash_branch_index=${branch_index}
        fi
        if [ ! -z "branch_stashes[${branch_index}]" ]; then
          branch_stashes[${branch_index}]="${branch_stashes[${branch_index}]} "
        fi
        branch_stashes[${branch_index}]="${branch_stashes[${branch_index}]}${stash_index}"
        stash_line_list_1[${stash_index}]="${stash_line:${stash_end}}"
        stash_line_list_2[${stash_index}]=""
        stash_line_list_3[${stash_index}]=""
        stash_line_list_4[${stash_index}]=""
        stash_line_list_branch[${stash_index}]="${stash_line:${stash_start}:${stash_middle} - ${stash_start}}"
        stash_line_list_branch[${stash_index}]="${stash_line_list_branch[${stash_index}]:3}"

        # If this comment probably was automatically generated by this program.
        # parse out its parts.
        if echo "${stash_line_list_1[${stash_index}]}" | grep -q "^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]"; then
          # First pull out the date...
          stash_date_value="${stash_line_list_1[${stash_index}]:0:19}"
          stash_auto_comment_value="${stash_line_list_1[${stash_index}]:20}"

          # then pull out the type.
          if echo "${stash_auto_comment_value}" | grep -q "^(.*) "; then
            stash_start=0
            #(
            while [ "${stash_auto_comment_value:${stash_start}:2}" != ") " ]; do
              stash_start=$((${stash_start} + 1))
            done
            stash_type_value="${stash_auto_comment_value:1:$((${stash_start} - 1))}"
            stash_auto_comment_value="${stash_auto_comment_value:${stash_start} + 2}"

            if [ ! -z "${prompt_search_text}" ]; then
              if [ "${branch_name}" = "${recorded_name}" ]; then
                if [ "${prompt_search_text}" = "${stash_type_value}" ]; then
                  found_stash="true"
                  if [ -z "${found_stash_index}" ]; then
                    found_stash_index="${stash_index}"
                  fi
                fi
              fi
            fi
          fi

          # Then pull out the user comment
          if echo "${stash_auto_comment_value}" | grep -q "^- .* - "; then
            stash_start=2
            #(
            while [ "${stash_auto_comment_value:${stash_start}:3}" != " - " ]; do
              stash_start=$((${stash_start} + 1))
            done
            stash_user_comment_value="${stash_auto_comment_value:2:$((${stash_start} - 2))}"
            stash_auto_comment_value="${stash_auto_comment_value:${stash_start} + 3}"
          fi
          unset set_stash_lines

          if [ ! -z "${stash_user_comment_value}" ]; then
            set_stash_lines[${#set_stash_lines[@]}]="Comment:    ${stash_user_comment_value}"
          fi
          if [ ! -z "${stash_type_value}" ]; then
            set_stash_lines[${#set_stash_lines[@]}]="Type:       ${stash_type_value}"
          fi
          if [ ! -z "${stash_date_value}" ]; then
            set_stash_lines[${#set_stash_lines[@]}]="Date:       ${stash_date_value}"
          fi
          if [ ! -z "${stash_auto_comment_value}" ]; then
            set_stash_lines[${#set_stash_lines[@]}]="Stash base: ${stash_auto_comment_value}"
          fi
          stash_line_list_1[${stash_index}]="${set_stash_lines[0]}"
          format_line_with_prefix "      " "${stash_line_list_1[${stash_index}]}" "                  " stash_print_line_formatted
          stash_line_list_1[${stash_index}]="${stash_print_line_formatted:6}"
          stash_line_list_2[${stash_index}]="${set_stash_lines[1]}"
          stash_line_list_3[${stash_index}]="${set_stash_lines[2]}"
          stash_line_list_4[${stash_index}]="${set_stash_lines[3]}"
        else
          stash_line_list_1[${stash_index}]="Stash base: ${stash_line_list_1[${stash_index}]}"
          format_line_with_prefix "      " "${stash_line_list_1[${stash_index}]}" "                  " stash_print_line_formatted
          stash_line_list_1[${stash_index}]="${stash_print_line_formatted:6}"
        fi

        if [ -z "${stash_prompt}" ]; then
          if [ ! -z "${selected_list_value}" ]; then
            selected_list_value="${selected_list_value}${return_line}"
          fi
          selected_list_value="${selected_list_value}${stash_list[${stash_index}]}"
        fi
      fi
    fi
  done <<< "${stashed_items}"

  if [ -z "${prompt_search_text}" ]; then
    found_stash="true"
    found_stash_index="0"
  else
    if [ -z "${found_stash_index}" ]; then
      found_stash_index="0"
    else
      base_stash_branch_index="0"
    fi
  fi

  if [ "${found_stash}" = "true" ]; then
    if [ ${#stash_list[@]} -gt 0 ]; then
      declare -a stash_menu_item_list

      if [ "${stash_show_default}" = "true" ]; then
        if [ -z "${prompt_search_text}" ]; then
          if [ "${base_stash_branch_index}" = "0" ]; then
            stash_menu_item_line_text="Most recent stash (from this branch):"
          else
            stash_menu_item_line_text="Most recent stash (from branch \"${branch_list[${base_stash_branch_index}]}\"):"
          fi
        else
          stash_menu_item_line_text="The most recent stash for this branch from switching:"
        fi
        format_line "${stash_menu_item_line_text}" "" stash_print_line_formatted
        stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"

        format_line_for_menu "0" "" "${stash_line_list_1[${found_stash_index}]}" stash_print_line_formatted
        stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        if [ ! -z "${stash_line_list_2[${found_stash_index}]}" ]; then
          format_line_with_prefix "      " "${stash_line_list_2[${found_stash_index}]}" "                  " stash_print_line_formatted
          stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        fi
        if [ ! -z "${stash_line_list_3[${found_stash_index}]}" ]; then
          format_line_with_prefix "      " "${stash_line_list_3[${found_stash_index}]}" "                  " stash_print_line_formatted
          stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        fi
        if [ ! -z "${stash_line_list_4[${found_stash_index}]}" ]; then
          format_line_with_prefix "      " "${stash_line_list_4[${found_stash_index}]}" "                  " stash_print_line_formatted
          stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        fi
        format_line_with_prefix "      " "Branch:     ${stash_line_list_branch[${found_stash_index}]}" "                  " stash_print_line_formatted
        stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        list_stash_index[${#list_stash_index[@]}]=${found_stash_index}
      fi

      branch_index=0
      while [ ${branch_index} -lt ${#branch_list[@]} ]; do
        stash_menu_item_list[${#stash_menu_item_list[@]}]=""
        format_line "Branch: ${branch_list[${branch_index}]}" "" stash_print_line_formatted
        stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"

        branch_stash_index=0
        branch_stash_array=(${branch_stashes[${branch_index}]})
        if [ "${#branch_stash_array[@]}" = "0" ]; then
          format_line_with_prefix "    " "There are no stashes for this branch." "    " stash_print_line_formatted
          stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
        else
          while [ ${branch_stash_index} -lt ${#branch_stash_array[@]} ]; do
            stash_index=${branch_stash_array[${branch_stash_index}]}
            list_index=${#list_stash_index[@]}
            list_stash_index[${list_index}]=${stash_index}
            stash_menu_index=${list_index}
            if [ "${stash_show_default}" != "true" ]; then
              stash_menu_index=$((${stash_menu_index} + 1))
            fi

            if [ ${branch_stash_index} -gt 0 ]; then
              stash_menu_item_list[${#stash_menu_item_list[@]}]=""
            fi

            format_line_for_menu "${stash_menu_index}" "" "${stash_line_list_1[${stash_index}]}" stash_print_line_formatted
            stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
            if [ ! -z "${stash_line_list_2[${stash_index}]}" ]; then
              format_line_with_prefix "      " "${stash_line_list_2[${stash_index}]}" "                  " stash_print_line_formatted
              stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
            fi
            if [ ! -z "${stash_line_list_3[${stash_index}]}" ]; then
              format_line_with_prefix "      " "${stash_line_list_3[${stash_index}]}" "                  " stash_print_line_formatted
              stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
            fi
            if [ ! -z "${stash_line_list_4[${stash_index}]}" ]; then
              format_line_with_prefix "      " "${stash_line_list_4[${stash_index}]}" "                  " stash_print_line_formatted
              stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"
            fi
            format_line_with_prefix "      " "Branch:     ${stash_line_list_branch[${stash_index}]}" "                  " stash_print_line_formatted
            stash_menu_item_list[${#stash_menu_item_list[@]}]="${stash_print_line_formatted}"

            branch_stash_index=$((${branch_stash_index} + 1))
          done
        fi

        branch_index=$((${branch_index} + 1))
      done

      stash_one_based="true"
      if [ "${stash_show_default}" = "true" ]; then
        stash_one_based="false"
      fi
      while [ -z "${menu_selected_list_value}" ]; do
        if [ ! -z "${stash_prompt}" -o -z "${stash_branch_filter}" -o ! -z "${selected_list_value}" ]; then
          echo ""
          present_menu stash_menu_item_list[@] "${stash_one_based}" "0" "${stash_pre_text}" "${stash_prompt}" menu_selected_list_value "true" "${#list_stash_index[@]}"
        else
          menu_selected_list_value="0"
        fi
      done

      if [ ! -z "${stash_prompt}" ]; then
        selected_list_value="${stash_list[${list_stash_index[${menu_selected_list_value}]}]}"
      fi
    fi
  fi

  set_param_value "${sel_stash_var}" "${selected_list_value}"
}

function commit_changes
{
  # This funciton will commit the current changes to the branch.

  cd ${build_base_directory}

  commit_merge_ok="true"
  validate_merge_conflicts commit_merge_ok

  if [ "${commit_merge_ok}" = "true" ]; then
    set +e
    # commit_staged_changes="$(git status --porcelain | grep -v "${merge_conflict_status_grep}" | grep "^[MDARC]")"
    commit_unstaged_changes="$(git status --porcelain | grep -v "${merge_conflict_status_grep}" | grep -v "^[MDARC]")"
    set -e

    if [ ! -z "${commit_unstaged_changes}" ]; then
      yes_no_prompt "You have unstaged changes.  Would you like to add these files and commit them? (y/n): " "y" commit_yes_no_result
      if [ "${commit_yes_no_result}" = "y" ]; then
        execute_command "git add ." "" "" ""
      fi
    fi

    read -p "Please type a comment for this commit: " commit_comment
    echo ""
    if [ ! -z "${commit_comment}" ]; then
      commit_comment=" -m \"${commit_comment//\"/\\\"}\""
    fi

    execute_command "git commit${commit_comment}" "" "" ""
  fi
}

function stash_changes
{
  # Stash the changes.
  #
  # PARAMETERS:
  #   ${1}  - set_stash_type      - The type of stash beng saved.
  #   ${2}  - user_comment_value  - Text to be added to the comment after the date.

  set_stash_type="${1}"
  user_comment_value="${2}"

  additional_comment=""

  cd ${build_base_directory}

  record_history "  # Stash Changes"
  record_branch recorded_name

  if [ ! -z "${set_stash_type}" ]; then
    additional_comment="${additional_comment} (${set_stash_type})"
  fi

  default_comment="$(git branch -v | grep "^* ${recorded_name}")"
  default_comment="${default_comment:${#recorded_name} + 2}"
  ltrim_line "${default_comment}" default_comment

  if [ -z "${user_comment_value}" ]; then
    read -p "Enter a comment for this stash (If no comment, just hit enter): " stash_user_comment
    echo ""
  else
    stash_user_comment="${user_comment_value}"
  fi

  if [ ! -z "${stash_user_comment}" ]; then
    additional_comment="${additional_comment} - ${stash_user_comment} - "
  fi
  default_comment="$(date ${time_format_sting})${additional_comment} ${default_comment}"

  execute_command "git stash save --include-untracked \"${default_comment}\"" "" "" ""
}

function prompt_apply_stash
{
  # Prompt a list of stashes that can be applied then apply it
  #
  # PARAMETERS:
  #   ${1}  - apply_prompt_search_text  - If a stash with this text for this branch does
  #                                       not exist, do not prompt.
  #   ${2}  - apply_sel_stash_var       - The variable to return the stash index in.

  apply_prompt_search_text="${1}"
  apply_sel_stash_var="${2}"

  cd ${build_base_directory}

  check_branch_for_switch "" "" "" "false"

  show_stash_list_menu "" "Please type the number of the stash to apply: " "true" apply_selected_stash "${apply_prompt_search_text}" ""
  perform_apply_stash "${apply_selected_stash}"

  set_param_value "${apply_sel_stash_var}" "${apply_selected_stash}"
}

function perform_apply_stash
{
  # Perform the apply of a stash
  #
  # PARAMETERS:
  #   ${1}  - apply_stash_name  - The name (stash@{#}) of the stash to be applied...

  cd ${build_base_directory}

  apply_stash_name="${1}"

  if [ ! -z "${apply_stash_name}" ]; then
    record_history "  # Apply branch ${apply_stash_name}"
    execute_command "git stash apply --index ${apply_stash_name}" "" stash_apply_success stash_apply_text

    echo "${stash_apply_text}"

    if echo "${stash_apply_text}" | grep "Conflicts in index."; then
      echo "Retrying stash without the --index:"
      execute_command "git stash apply ${apply_stash_name}" "" stash_apply_success ""
    fi
  fi
}

function prompt_drop_stash
{
  # Prompt a list of stashes that can be applied then drop it
  cd ${build_base_directory}

  show_stash_list_menu "" "Please type the number of the stash to delete: " "true" selected_stash "" ""
  perform_drop_stash "${selected_stash}" "true"
}

function perform_drop_stash
{
  # Perform the drop of a stash
  #
  # PARAMETERS:
  #   ${1}  - drop_stash_name     - The name (stash@{#}) of the stash to be applied...
  #   ${2}  - confirm_drop_stash  - True to confirm to drop the stash.

  cd ${build_base_directory}

  drop_stash_name="${1}"
  confirm_drop_stash="${2}"

  if [ ! -z "${drop_stash_name}" ]; then
    if [ "${confirm_drop_stash}" = "false" ]; then
      drop_stash_confirm="y"
    else
      yes_no_prompt "A stash drop cannot be undone.  Are you sure you want to do this? (y/n): " "" drop_stash_confirm
    fi

    if [ "${drop_stash_confirm}" = "y" ]; then
      record_history "  # Drop branch ${drop_stash_name}"
      execute_command "git stash drop ${drop_stash_name}" "" "" ""
    fi
  fi
}

function prompt_unapply_stash
{
  # Prompt a list of stashes that can be applied then unapply it
  cd ${build_base_directory}

  show_stash_list_menu "" "Please type the number of the stash to unapply: " "true" selected_stash "" ""
  perform_unapply_stash "${selected_stash}"
}

function perform_unapply_stash
{
  # Perform the unapply of a stash
  #
  # PARAMETERS:
  #   ${1}  - unapply_stash_name  - The name (stash@{#}) of the stash to be applied...

  cd ${build_base_directory}

  unapply_stash_name="${1}"

  if [ ! -z "${unapply_stash_name}" ]; then
    record_history "  # Unapply branch ${unapply_stash_name}"
    execute_command "git stash show -p ${unapply_stash_name} | git apply -R" "" "" ""
  fi
}

function perform_clear_stash
{
  # Perform the clear of a stash

  cd ${build_base_directory}

  record_history "  # Clear stash history"
  execute_command "git stash clear" "" "" ""
}

function clean_repository
{
  # Do a clean of the git repository.

  cd ${build_base_directory}

  cleaned_files="$(git clean -n -d)"
  if [ ! -z "${cleaned_files}" ]; then
    hard_reset_confirm=""
    cleaned_files="$(git clean -n -d)"
    yes_no_prompt "The following untracked files can be removed:${return_line}${return_line}${cleaned_files}${return_line}${return_line}Are you sure you want to remove these files? (y/n): " "" hard_reset_confirm

    if [ "${hard_reset_confirm}" = "y" ]; then
      record_history "  # Clean repository"
      execute_command "git clean -f -d" "" "" ""
    fi
  fi
}

function hard_reset_repository
{
  # Do a hard reset of the git repository.
  #
  # PARAMETERS:
  #   ${1}  - hard_reset_prompt_clean   - true/false if the reset should offer to clean the repository also
  #   ${2}  - hard_reset_performed_var  - The variable to return if the hard reset was done.

  hard_reset_prompt_clean="${1}"
  hard_reset_performed_var="${2}"

  cd ${build_base_directory}

  performed_hard_reset="false"
  hard_reset_confirm=""
  set +e
  updated_files="$(git status --porcelain | grep -v "??")"
  set -e

  if [ -z "${updated_files}" ]; then
    echo "There are no updated files to reset."
    hard_reset_confirm="x"
    performed_hard_reset="true"
  else
    yes_no_prompt "A hard reset cannot be undone.  The following files will have their changes undone:${return_line}${return_line}${updated_files}${return_line}${return_line}Are you sure you want to do this? (y/n): " "" hard_reset_confirm
  fi

  if [ "${hard_reset_confirm}" = "y" ]; then
    record_history "  # Hard reset"
    execute_command "git reset --hard" "" "" ""
    performed_hard_reset="true"
  fi

  if [ "${performed_hard_reset}" = "true" ]; then
    clean_repository
  fi

  set_param_value "${hard_reset_performed_var}" "${performed_hard_reset}"
}

function show_stash_menu
{
  declare -a stash_menu_options

  stash_menu_options[${#stash_menu_options[@]}]="Stash"
  stash_menu_options[${#stash_menu_options[@]}]="Apply"
  stash_menu_options[${#stash_menu_options[@]}]="Delete"
  stash_menu_options[${#stash_menu_options[@]}]="Save (Stash then Apply)"
  stash_menu_options[${#stash_menu_options[@]}]="Un-Apply"
  stash_menu_options[${#stash_menu_options[@]}]="Clear all stash history"
  stash_menu_options[${#stash_menu_options[@]}]="List stashes"
  stash_menu_options[${#stash_menu_options[@]}]="Hard reset (not a stash option, but convenient here.)"
  stash_menu_options[${#stash_menu_options[@]}]="Clean directories (not a stash option, but convenient here.)"

  present_menu stash_menu_options[@] "false" "0" "Stashing options:" "Select the stash command you want to do: " selected_stash_option "false" "0"

  case "${selected_stash_option}" in
    # (
    "0")
    stash_changes "" ""
    ;;

    # (
    "1")
    prompt_apply_stash "" applied_stash
    ;;

    # (
    "2")
    prompt_drop_stash
    ;;

    # (
    "3")
    stash_changes "save" ""
    perform_apply_stash "stash@{0}"
    ;;

    # (
    "4")
    prompt_unapply_stash
    ;;

    # (
    "5")
    perform_clear_stash
    ;;

    # (
    "6")
    show_stash_list_menu "" "" "true" list_stashes_return "" ""
    ;;

    # (
    "7")
    hard_reset_repository "true" hard_reset_success
    ;;

    # (
    "8")
    clean_repository
    ;;
  esac
}

function get_git_porcelain_file_name
{
  # This function extracts the file name from a line from git status --porcelain
  #
  # PARAMETERS:
  #   ${1}  - porcelain_line    - The porcelain line
  #   ${2}  - git_file_name_var - The variable to return the filename in

  porcelain_line="${1}"
  git_file_name_var="${2}"

  is_quoted="false"
  if [ "${porcelain_line:${#porcelain_line} - 1:1}" = "\"" ]; then
    is_quoted="true"
  fi
  if [ "${is_quoted}" = "true" ]; then
    porcelain_line="${porcelain_line:0:${#porcelain_line} - 1}"
  fi
  file_name_start=$((${#porcelain_line} - 1))
  while [ ${file_name_start} -ge 0 ]; do
    if [ "${is_quoted}" = "true" ]; then
      if [ "${porcelain_line:${file_name_start}:1}" = "\"" ]; then
        if [ ${file_name_start} -gt 0 ]; then
          if [ "${porcelain_line:${file_name_start} - 1:1}" = "\\" ]; then
            file_name_start=$((${file_name_start} - 1))
          fi
        fi
      fi
      if [ "${porcelain_line:${file_name_start}:1}" = "\"" ]; then
        break
      fi
    else
      if [ "${porcelain_line:${file_name_start}:1}" = " " ]; then
        break
      fi
    fi
    file_name_start=$((${file_name_start} - 1))
  done
  file_name_start=$((${file_name_start} + 1))

  set_param_value "${git_file_name_var}" "${porcelain_line:${file_name_start}}"
}

function validate_merge_conflicts
{
  # This function checks git status to find files which had merge conflicts
  # and which need to be verified.
  #
  # PARAMETERS:
  #   ${1}  - validation_completed_successfully_var - True/false if the merge check is OK.

  validation_completed_successfully_var="${1}"

  cd ${build_base_directory}

  merge_is_ok="true"

  if git status --porcelain | grep -q "${merge_conflict_status_grep}"; then
    # We know that there was a merge, so check it out...
    declare -a conflict_line_list
    declare -a resolved_conflict_files

    cd ${build_base_directory}

    conflict_status="$(git status --porcelain)"

    merge_check_files_have_conflicts="false"
    continue_merge_check="n"
    while read conflict_line; do
      if [ ! -z "${conflict_line}" ]; then
        conflict_line_list[${#conflict_line_list[@]}]="${conflict_line}"
      fi
    done <<< "${conflict_status}"

    conflict_line_index=0
    while [ ${conflict_line_index} -lt ${#conflict_line_list[@]} ]; do
      conflict_line="${conflict_line_list[${conflict_line_index}]}"

      is_update_line="false"
      is_delete_line="false"
      if [ "${conflict_line:0:1}" = "U" ]; then
        is_update_line="true"
      fi
      if [ "${conflict_line:1:1}" = "U" ]; then
        is_update_line="true"
      fi
      if [ "${conflict_line:0:2}" = "AA" ]; then
        is_update_line="true"
      fi
      if [ "${conflict_line:0:1}" = "D" -a "${conflict_line:1:1}" != " " ]; then
        is_delete_line="true"
      fi
      if [ "${conflict_line:1:1}" = "D" -a "${conflict_line:0:1}" != " " ]; then
        is_delete_line="true"
      fi

      if [ "${is_delete_line}" = "true" ]; then
        is_update_line="false"
        get_git_porcelain_file_name "${conflict_line}" file_name_conflict
        if [ "${conflict_line:0:1}" = "D" ]; then
          diff_line_output="The file \"${file_name_conflict}\" was deleted locally and re-added by the merge because it was edited.  If you continue, the file will be added back.  This is likely a merge error.${return_line}${return_line}You should stop the merge and inspect the file to determine what was changed and resolve the conflict.  If you contine, your delete will be undone.${return_line}Do you want to stop now? (y/n): "
        else
          diff_line_output="The file \"${file_name_conflict}\" was edited locally and deleted by the merge.  If you continue, the file will be added back.  This is likely a merge error.${return_line}${return_line}You should stop the merge and review your changes to determine if they should be moved to another file.  If you contine, the file will be re-added to the merge.${return_line}Do you want to stop now? (y/n): "
        fi
        yes_no_prompt "${diff_line_output}" "y" continue_merge_check
        if [ "${continue_merge_check}" = "y" ]; then
          merge_is_ok="false"
          break
        else
          merge_is_ok="true"
          resolved_conflict_files[${#resolved_conflict_files[@]}]="${file_name_conflict}"
        fi
      fi

      if [ "${is_update_line}" = "true" ]; then
        get_git_porcelain_file_name "${conflict_line}" file_name_conflict

        if git diff ${file_name_conflict} | grep -q "<<<<"; then
          format_line "[00;31m${file_name_conflict}[00m still shows conflicts..." "" diff_line_output
          echo "${diff_line_output}"
          merge_check_files_have_conflicts="true"
        else
          format_line "[00;32m${file_name_conflict}[00m has been properly resolved..." "" diff_line_output
          echo "${diff_line_output}"

          resolved_conflict_files[${#resolved_conflict_files[@]}]="${file_name_conflict}"
        fi
      fi

      conflict_line_index=$((${conflict_line_index} + 1))
    done

    if [ "${merge_is_ok}" = "true" ]; then
      merge_is_ok="false"
      if [ "${merge_check_files_have_conflicts}" = "false" ]; then
        commit_merge_conflicts=""
        yes_no_prompt "All conflict files have been resolved.  Are you ready to add these files and commit? (y/n): " "" commit_merge_conflicts
        if [ "${commit_merge_conflicts}" = "y" ]; then
          conflict_file_index=0
          while [ ${conflict_file_index} -lt ${#resolved_conflict_files[@]} ]; do
            execute_command "git add ${resolved_conflict_files[${conflict_file_index}]}" "" "" ""
            conflict_file_index=$((${conflict_file_index} + 1))
          done
          execute_command "git commit -m \"Merge conflict resolution - $(date ${time_format_sting})\"" "" "" ""
          merge_is_ok="true"
        fi
      fi
    fi
  fi

  set_param_value "${validation_completed_successfully_var}" "${merge_is_ok}"
}

function recreate_database_schema
{
  # NOTE: This function is still build exclusively/special for sparrow_crm.
  #       I'll work on a generic version of this later if needed/wanted...
  #
  # This funciton ensures that the checked in schema.rb file for the host is correct.
  # It does this by recreating the database from scratch and dumping the schema file.
  #
  # This feature was added because there were problems with recent migrations which
  # caused problems.  This is what we had to do in order to correct the problem,
  # and the steps are bizarre enough that they are worth documenting and automating.

  cd ${build_base_directory}

  # Validate DB schema
  # # I don't think we actually need to recreate the database and the schema.rb
  # # file for the engine, but it isn't a bad habit/idea.
  # # The reason for doing this is so that the test has the correct schema.rb
  # # that it will need for tests if/when the test database is recreated.
  #
  # # Doing the drop/create/migrate in spec/dummy will cause the base tables needed
  # # to be created.  We then instal the engine migrations, then we can dump the schema.
  #   sparrow_core_models/spec/dummy
  #     db:drop db:create db:migrate
  #   sparrow_core_models
  #     db:migrate
  #   sparrow_core_models/spec/dummy
  #     db:schema:dump
  #     db:drop
  #
  # # For the host, we install the migrations from all of the engines, then
  # # drop the database and create it through migrations (create then migrate)
  # # any other method will use the schema.rb file, which we don't want to use.
  #   sparrow_host
  #     sparrow_core_models:install:migrations
  #     db:drop db:create db:migrate db:seed db:schema:dump

  if [ -d ${build_base_directory}/sparrow_host ]; then
    declare -a migrate_folder_list

    schema_dump_db_folders="$(find . -name db)"
    if [ ! -z "${schema_dump_db_folders}" ]; then
      while read schema_dump_db_path; do
        cd ${build_base_directory}
        if [ -d ${schema_dump_db_path} ]; then
          if ! echo "${schema_dump_db_path}" | grep -q ".git/"; then
            if ! echo "${schema_dump_db_path}" | grep -q "sparrow_crm"; then
              if ! echo "${schema_dump_db_path}" | grep -q "sparrow_host"; then
                if ! echo "${schema_dump_db_path}" | grep -q "spec/dummy"; then
                  # The folder exists, is not sparrow_crm, sparrow_host, and not spec/dummy.
                  # Therefore, this folder has DB migrations we need to include in our program.
                  schema_dump_db_path="${schema_dump_db_path:2:${#schema_dump_db_path} - 5}"
                  migrate_folder_list[${#migrate_folder_list[@]}]=${schema_dump_db_path}

                  cd ${build_base_directory}/${schema_dump_db_path}
                  if [ -d spec/dummy/db ]; then
                    cd spec/dummy
                    execute_command "bundle install" "" "" ""
                    execute_command "RAILS_ENV=test bundle exec rake db:drop db:create db:migrate" "" "" ""
                    cd ../..
                    execute_command "bundle install" "" "" ""
                    execute_command "RAILS_ENV=test bundle exec rake db:migrate" "" "" ""
                    cd spec/dummy
                    execute_command "RAILS_ENV=test bundle exec rake db:schema:dump db:drop" "" "" ""
                  fi
                fi
              fi
            fi
          fi
        fi
      done <<< "${schema_dump_db_folders}"
    fi

    if [ ${#migrate_folder_list[@]} -gt 0 ]; then
      cd ${build_base_directory}/sparrow_host

      schema_dump_db_index=0
      while [ ${schema_dump_db_index} -lt ${#migrate_folder_list[@]} ]; do
        execute_command "RAILS_ENV=test bundle exec rake ${migrate_folder_list[${schema_dump_db_index}]}:install:migrations" "" "" ""

        schema_dump_db_index=$((${schema_dump_db_index} + 1))
      done

      execute_command "RAILS_ENV=test bundle exec rake db:drop db:create db:migrate db:seed db:schema:dump db:drop" "" "" ""
    fi
  fi
}

function branch_database_menu
{
  # This function presents menu options to branch or unbranch the database as well as the
  # the rest of the code.

  record_branch recorded_name

  cd ${build_base_directory}

  config_recorded_name="${recorded_name//-/_}"
  set +e
  db_branch_configuration="$(git config --bool branch.${config_recorded_name}.database)"
  set -e

  if [ "${db_branch_configuration}" = "true" ]; then
    branch_db_message="The branch ${recorded_name} is configured to branch the database.${return_line}${return_line}Do you want to switch the database back from the branch to the main database? (y/n): "
  else
    branch_db_message="The branch ${recorded_name} is not configured to branch the database.${return_line}${return_line}Do you want to switch the database to be branched from the main database? (y/n): "
  fi

  format_line "${branch_db_message}" "" branch_db_message
  switch_database_branching=""
  echo "${return_line}"
  yes_no_prompt "${branch_db_message}" "y" switch_database_branching

  if [ "${switch_database_branching}" = "y" ]; then
    if [ "${db_branch_configuration}" = "true" ]; then
      execute_command "git config --unset branch.${config_recorded_name}.database" "" "" ""
    else
      execute_command "git config --bool branch.${config_recorded_name}.database \"true\"" "" "" ""
    fi
  fi
}

function split_directory
{
  # This function splits a passed in file name into a directory and a file name
  # This function is stupid in how it does this and does not validate that
  # the file or directory are valid or structured properly.
  #
  # PARAMETERS:
  #   ${1}  - split_directory_full_file_name        - The full path to split
  #   ${2}  - split_directory_return_directory_var  - The variable to return the directory into
  #   ${3}  - split_directory_return_file_name_var  - The variable to return the file name into

  split_directory_full_file_name="${1}"
  split_directory_return_directory_var="${2}"
  split_directory_return_file_name_var="${3}"

  rest_of_file_name="${split_directory_full_file_name}"
  while [ ! -z "${rest_of_file_name}" ]; do
    split_line_on_char "${rest_of_file_name}" "/" split_file_name rest_of_file_name
  done

  split_directory_name=""
  if [ ${#split_file_name} -lt ${#split_directory_full_file_name} ]; then
    split_directory_name="${split_directory_full_file_name:0:${#split_directory_full_file_name} - ${#split_file_name} - 1}"
  fi

  set_param_value "${split_directory_return_directory_var}" "${split_directory_name}"
  set_param_value "${split_directory_return_file_name_var}" "${split_file_name}"
}

function show_create_patch_menu
{
  # This function will create and display a menu fo creating a patch file

  declare -a patch_menu_options
  declare -a patch_menu_diff

  cd ${build_base_directory}

  record_branch create_patch_branch_name
  get_origin_branch "${create_patch_branch_name}" "pull" "false" create_patch_remote_name
  if [ -z "${create_patch_remote_name}" ]; then
    # normally we don't do this, but for creating a patch, this is what we want to do...
    create_patch_remote_name="master"
  fi

  actual_create_patch_file_name="${create_patch_file_name}"

  if [ "${actual_create_patch_file_name:0:1}" != "/" ]; then
    actual_create_patch_file_name="${current_directory}/${actual_create_patch_file_name}"
  fi

  if [ -f "${actual_create_patch_file_name}" ]; then
    yes_no_prompt "The file \"${actual_create_patch_file_name}\" already exists.  In order to create a patch, this file will first need to be deleted.${return_line}${return_line}Do you want to delete this file? (y/n): " "" delete_existing_patch_file
    if [ "${delete_existing_patch_file}" = "y" ]; then
      rm ${actual_create_patch_file_name}
    fi
  fi

  # check_branch_for_switch

  patch_merge_ok="true"
  validate_merge_conflicts patch_merge_ok

  # I tried several options for creating patch files.  The git diff supposedly outputs a patch
  # format that can be applied, but I was never able to get this to actually work.
  #
  # The only option that I was able to get to work was git format-patch of commits.
  #
  # Because items must be committed, I investigated how to add uncommitted files to the patch.
  # I did come up with an option that almost works, but has some flakeyness in some fringe cases.
  #
  # Because of the flakyness, I am commenting out these changes.  Maybe later I can figure it out
  # better.
  #
  # Update - I found a way to get the diff patch to work only for uncommitted changes.
  #           working on updating the code to do this.

  patch_staged_changes=""
  patch_unstaged_changes=""
  patch_include_staged="false"
  patch_include_unstaged="false"

  if [ "${patch_merge_ok}" = "true" ]; then
    set +e
    patch_staged_changes="$(git status --porcelain | grep -v "${merge_conflict_status_grep}" | grep "^[MDARC]")"
    patch_unstaged_changes="$(git status --porcelain | grep -v "${merge_conflict_status_grep}" | grep "^\(.[MDARC]\|??\)")"
    set -e

    # This line prevents the uncommitted changes from being able to be added to the patch
    if [ 1 = 2 ]; then
      if [ ! -z "${patch_staged_changes}" -o ! -z "${patch_unstaged_changes}" ]; then
        patch_menu_options[${#patch_menu_options[@]}]="Changes not committed yet."
        patch_menu_diff[${#patch_menu_diff[@]}]="HEAD"
      fi
    fi

    if [ 1 = 2 ]; then
      # This is technically correct, but it takes more time than it is worth.
      # So I've removed it, but I don't want to just eliminate it cause it is kinda cool...
      num_commits_in_log="$(git log | grep "^Author: " | wc -l)"
      if [ ! -z "${num_commits_in_log}" ]; then
        get_line_number "${num_commits_in_log}" "false" num_commits_in_log
      else
        num_commits_in_log=0
      fi
    else
      num_commits_in_log=2000
    fi

    patch_menu_options[${#patch_menu_options[@]}]="Changes that have been checked in that have not been pushed"
    patch_menu_diff[${#patch_menu_diff[@]}]="origin/${create_patch_remote_name}..HEAD"

    patch_menu_options[${#patch_menu_options[@]}]=""

    if [ "${create_patch_remote_name}" != "master" ]; then
      patch_menu_options[${#patch_menu_options[@]}]="Changes checked into the current branch compared to origin/master"
      patch_menu_diff[${#patch_menu_diff[@]}]="origin/master..HEAD"
      patch_menu_options[${#patch_menu_options[@]}]="Changes pushed to the current branch compared to origin/master"
      patch_menu_diff[${#patch_menu_diff[@]}]="origin/master..origin/${create_patch_remote_name}"
    fi
    if [ ${num_commits_in_log} -gt 0 ]; then
      patch_menu_options[${#patch_menu_options[@]}]="Last N commits"
      patch_menu_diff[${#patch_menu_diff[@]}]="last n"
    fi

    if [ ! -z "${patch_staged_changes}" -o ! -z "${patch_unstaged_changes}" ]; then
      patch_menu_options[${#patch_menu_options[@]}]=""

      patch_menu_options[${#patch_menu_options[@]}]="Changes that have not been committed"
      patch_menu_diff[${#patch_menu_diff[@]}]="diff HEAD"
    fi
    if [ ! -z "${patch_staged_changes}" ]; then
      patch_menu_options[${#patch_menu_options[@]}]="Changes that have been staged"
      patch_menu_diff[${#patch_menu_diff[@]}]="diff --cached"
    fi
    if [ ! -z "${patch_unstaged_changes}" ]; then
      patch_menu_options[${#patch_menu_options[@]}]="Changes that have not been staged"
      if echo "${patch_unstaged_changes}" | grep -q "^??"; then
        patch_menu_options[$((${#patch_menu_options[@]} - 1))]="${patch_menu_options[$((${#patch_menu_options[@]} - 1))]} (excluding new files)${return_line}NOTE:  This patch is created using git diff which will not include unstaged files not in the repository.  If you want to include any of these files in your patch, you must commit or stage these files before generating the patch."
      fi
      patch_menu_diff[${#patch_menu_diff[@]}]="diff"
    fi

    present_menu patch_menu_options[@] "true" "0" "Create a patch from what changes:" "Select the type of changes you wish to create a patch from: " selected_patch_changes_option "false" "0"

    # This line prevents the uncommitted changes from being able to be added to the patch
    if [ 1 = 2 ]; then
      if [ ! -z "${patch_staged_changes}" -o ! -z "${patch_unstaged_changes}" ]; then
        declare -a patch_unstaged_changes_menu_options
        declare -a patch_unstaged_changes_menu_values

        patch_unstaged_yes_no=""
        if [ ! -z "${patch_staged_changes}" -a ! -z "${patch_unstaged_changes}" ]; then
          patch_unstaged_changes_menu_options[${#patch_unstaged_changes_menu_options[@]}]="Both unstaged and staged changes"
          patch_unstaged_changes_menu_values[${#patch_unstaged_changes_menu_values[@]}]="both"
        fi
        if [ ! -z "${patch_staged_changes}" ]; then
          patch_unstaged_changes_menu_options[${#patch_unstaged_changes_menu_options[@]}]="Only staged changes"
          patch_unstaged_changes_menu_values[${#patch_unstaged_changes_menu_values[@]}]="staged"
          if [ -z "${patch_unstaged_changes}" ]; then
            patch_unstaged_yes_no="You have staged changes which have not been committed.  Do you want to include these changes in the patch? (y/n): "
          fi
        fi
        if [ ! -z "${patch_unstaged_changes}" -a -z "${patch_staged_changes}" ]; then
          patch_unstaged_yes_no="You have changes which have not been committed.  Do you want to include these changes in the patch? (y/n): "
        fi
        patch_unstaged_changes_menu_options[${#patch_unstaged_changes_menu_options[@]}]="Neither, only currently committed changes"
        patch_unstaged_changes_menu_values[${#patch_unstaged_changes_menu_values[@]}]="neither"

        if [ ! -z "${patch_unstaged_yes_no}" ]; then
          yes_no_prompt "${patch_unstaged_yes_no}" "y" patch_include_uncommitted
          if [ "${patch_include_uncommitted}" = "y" ]; then
            if [ ! -z "${patch_staged_changes}" ]; then
              patch_include_staged="true"
            else
              patch_include_staged="true"
              patch_include_unstaged="true"
            fi
          fi
        else
          present_menu patch_unstaged_changes_menu_options[@] "true" "0" "You have both staged and unstaged changes that have not been committed.  Please select which of the changes you want to include as part of the patch:" "Select the option for the items to be included: " patch_include_uncommitted_selection "false" "0"
          case "${patch_unstaged_changes_menu_values[${patch_include_uncommitted_selection}]}" in
            # (
            "both")
            patch_include_staged="true"
            patch_include_unstaged="true"
            ;;

            # (
            "staged")
            patch_include_staged="true"
            ;;

            # # (
            # "neither")
            # ;;
          esac
        fi
      fi
    fi
  fi

  if [ "${patch_menu_diff[${selected_patch_changes_option}]:0:4}" != "diff" ]; then
    if [ ! -z "${patch_staged_changes}" -o ! -z "${patch_unstaged_changes}" ]; then
      echo ""
      yes_no_prompt "You have uncommitted changes.  These changes cannot be included in the patch.  If you want to include these changes in the patch, you will need to commit them first.  Would you like to stop now so you can commit your changes? (y/n): " "y" patch_merge_ok

      if [ "${patch_merge_ok}" = "y" ]; then
        patch_merge_ok="false"
      else
        patch_merge_ok="true"
      fi
    fi
  fi

  if [ "${patch_include_staged}" = "true" ]; then
    echo ""
    yes_no_prompt "NOTE:  In order to create a patch which includes staged and/or unstaged changes, a stash will be created of your currently uncommitted changes, all changes will be committed, and then rolled back and the stash re-applied.  This could result in some previously staged changes being unstaged.${return_line}${return_line}Although this typically works well, it is strongly recommended that you commit any changes you would like in your patch before creating it.${return_line}${return_line}Would you like to continue? (y/n): " "n" patch_merge_ok

    if [ "${patch_merge_ok}" = "y" ]; then
      patch_merge_ok="true"
    else
      patch_merge_ok="false"
    fi
  fi

  if [ "${patch_merge_ok}" = "true" ]; then
    split_directory "${actual_create_patch_file_name}" actual_folder actual_file

    mkdir -p ${actual_folder}

    patch_last_n=""
    if [ "${patch_menu_diff[${selected_patch_changes_option}]}" = "last n" ]; then
      format_line "How many commits do you want to include in the patch: " "" patch_prompt_line
      while [ -z "${patch_last_n}" ]; do
        echo ""
        read -p "${patch_prompt_line}" patch_last_n
        echo ""
        if echo "${patch_last_n}" | grep -q "^[0-9]+$"; then
          echo "You must enter a number."
          patch_last_n=""
        fi
        if [ ! -z "${patch_last_n}" ]; then
          if [ ${patch_last_n} -le 0 -o ${patch_last_n} -gt ${num_commits_in_log} ]; then
            echo "You must enter a value between 1 and ${num_commits_in_log}."
            patch_last_n=""
          fi
        fi
      done
      patch_menu_diff[${selected_patch_changes_option}]="HEAD~${patch_last_n}..HEAD"
    fi

    patch_num_add=0
    # Save .D files here that do not currently exist.
    # Because restoring the stash sometimes gets this confused.
    declare -a patch_deleted_files

    if [ "${patch_include_staged}" = "true" ]; then
      patch_deleted_file_grep="$(git status --porcelain | grep "^[^U]D")"
      while read patch_deleted_file_name; do
        get_git_porcelain_file_name "${patch_deleted_file_name}" patch_deleted_file_name
        if [ ! -f ${patch_deleted_file_name} ]; then
          patch_deleted_files[${#patch_deleted_files[@]}]="${patch_deleted_file_name}"
        fi
      done <<< "${patch_deleted_file_grep}"

      execute_command "git stash save --include-untracked \"Temporary stash of uncommitted changes\"" "" "" ""
      execute_command "git stash apply --index stash@{0}" "" patch_apply_stash_success patch_apply_stash_text

      if echo "${patch_apply_stash_text}" | grep "Conflicts in index."; then
        echo "Retrying stash without the --index:"
        execute_command "git stash apply stash@{0}" "" patch_apply_stash_success ""
      fi

      patch_delete_index=0
      while [ ${patch_delete_index} -lt ${#patch_deleted_files[@]} ]; do
        if [ -f ${patch_deleted_files[${patch_delete_index}]} ]; then
          execute_command "rm ${patch_deleted_files[${patch_delete_index}]}" "" "" ""
        fi
        patch_delete_index=$((${patch_delete_index} + 1))
      done

      if [ ! -z "${patch_staged_changes}" ]; then
        execute_command "git commit -m \"Temporary commit to create a patch of uncommitted changes.\"" "" "" ""
        patch_num_add=$((${patch_num_add} + 1))
      fi

      if [ "${patch_include_unstaged}" = "true" ]; then
        execute_command "git add ." "" "" ""
        execute_command "git commit -m \"Temporary commit to create a patch of unstaged changes.\"" "" "" ""
        patch_num_add=$((${patch_num_add} + 1))
      fi

      if [ ! -z "${patch_last_n}" ]; then
        patch_last_n=$((${patch_last_n} + ${patch_num_add}))
        patch_menu_diff[${selected_patch_changes_option}]="HEAD~${patch_last_n}..HEAD"
      fi
    fi

    if [ "${patch_menu_diff[${selected_patch_changes_option}]:0:4}" = "diff" ]; then
      diff_option=""
      if [ ${#patch_menu_diff[${selected_patch_changes_option}]} -gt 4 ]; then
        diff_option="${patch_menu_diff[${selected_patch_changes_option}]:4}"
      fi
      execute_command "git diff --patch --full-index --binary${diff_option} > ${actual_create_patch_file_name}" "" "" ""
    else
      execute_command "git format-patch ${patch_menu_diff[${selected_patch_changes_option}]} --full-index --binary --stdout > ${actual_create_patch_file_name}" "" "" ""
    fi

    if [ "${patch_include_staged}" = "true" ]; then
      if [ "${patch_include_unstaged}" = "true" ]; then
        execute_command "git reset --hard HEAD~1" "" "" ""
      fi

      execute_command "git reset --hard HEAD~1" "" "" ""
      execute_command "git clean -f" "" "" ""
      execute_command "git stash apply --index stash@{0}" "" patch_apply_stash_success patch_apply_stash_text

      if echo "${patch_apply_stash_text}" | grep "Conflicts in index."; then
        echo "Retrying stash without the --index:"
        execute_command "git stash apply stash@{0}" "" patch_apply_stash_success ""
      fi

      patch_delete_index=0
      while [ ${patch_delete_index} -lt ${#patch_deleted_files[@]} ]; do
        if [ -f ${patch_deleted_files[${patch_delete_index}]} ]; then
          execute_command "rm ${patch_deleted_files[${patch_delete_index}]}" "" "" ""
        fi
        patch_delete_index=$((${patch_delete_index} + 1))
      done

      execute_command "git stash drop stash@{0}" "" "" ""
    fi
  fi
}

function apply_patch_file
{
  cd ${build_base_directory}

  record_branch apply_patch_branch_name

  actual_apply_patch_file_name="${apply_patch_file_name}"

  if [ "${actual_apply_patch_file_name:0:1}" != "/" ]; then
    actual_apply_patch_file_name="${current_directory}/${actual_apply_patch_file_name}"
  fi

  # Try to determine the type of file...
  # The different types of files have different apply options, so we'd like to know
  # which one it is...
  patch_head_line="$(head -n 1 ${actual_apply_patch_file_name})"
  is_format_patch="false"
  is_diff_patch="false"
  if [ ${#patch_head_line} -gt 5 ]; then
    if [ "${patch_head_line:0:5}" = "diff " ]; then
      is_diff_patch="true"
    else
      if [ "${patch_head_line:0:5}" = "From " ]; then
        is_format_patch="true"
      else
        set +e
        patch_from_pos="$(grep -n "^From: " ${actual_apply_patch_file_name})"
        if [ ! -z "${patch_from_pos}" ]; then
          get_line_number "${patch_from_pos}" "true" patch_from_pos
        else
          patch_from_pos=0
        fi
        patch_diff_pos="$(grep -n "^diff --git" ${actual_apply_patch_file_name})"
        if [ ! -z "${patch_diff_pos}" ]; then
          get_line_number "${patch_diff_pos}" "true" patch_diff_pos
        else
          patch_diff_pos=0
        fi
        set -e

        if [ ${patch_diff_pos} -gt 0 ]; then
          if [ ${patch_from_pos} -gt 0 ]; then
            if [ ${patch_diff_pos} -gt ${patch_from_pos} ]; then
              is_format_patch="true"
            else
              is_diff_patch="true"
            fi
          else
            is_diff_patch="true"
          fi
        else
          if [ ${patch_from_pos} -gt 0 ]; then
            is_format_patch="true"
          fi
        fi
      fi
    fi
  fi

  if [ "${is_format_patch}" = "true" ]; then
    apply_format_patch_file "${actual_apply_patch_file_name}"
  else
    if [ "${is_diff_patch}" = "true" ]; then
      apply_diff_patch_file "${actual_apply_patch_file_name}"
    else
      format_line "The format of the patch \"${actual_apply_patch_file_name}\" cannot be determined.  If you are sure it is a patch file, try running one of the following commands:${return_line}${return_line}cd ${build_base_directory}${return_line}git am --3way --ignore-whitespace ${actual_apply_patch_file_name}${return_line}git apply --index --ignore-whitespace ${actual_apply_patch_file_name}"
    fi
  fi
}

function apply_format_patch_file
{
  # This function applies a patch file from the format-apply command.
  #
  # PARAMETERS:
  #   ${1}  - format_patch_file_name  - The name of the patch file to apply.

  format_patch_file_name="${1}"

  # git am vs. git apply
  # For the most part, they do the same thing.  The main difference that I have seen so
  # far is that git am actually commits the different commits in the file, whereas
  # git apply only makes the changes, and leaves the commit (and message) up to you
  # to do later.
  execute_command "git am --3way --ignore-whitespace ${format_patch_file_name}" "" apply_success_status ""

  # execute_command "git apply --index --ignore-whitespace ${format_patch_file_name}" "" apply_success_status ""

  # if [ "${apply_success_status}" != "0" ]; then
  #   yes_no_prompt "The patch could not be fully applied with index updates.  Would you like to re-try applying the patch without the index update option? (y/n): " "y" re_apply_patch
  #   if [ "${re_apply_patch}" = "y" ]; then
  #     execute_command "git apply --ignore-whitespace ${format_patch_file_name}" "" "" ""
  #   fi
  # fi
}

function apply_diff_patch_file
{
  # This function applies a patch file from the diff --patch command.
  #
  # PARAMETERS:
  #   ${1}  - diff_patch_file_name  - The name of the patch file to apply.

  diff_patch_file_name="${1}"

  # git am vs. git apply
  # As far as I can tell, the git am will not work with patches generated from
  # git diff --patch
  execute_command "git apply --index --ignore-whitespace ${diff_patch_file_name}" "" apply_success_status ""

  if [ "${apply_success_status}" != "0" ]; then
    yes_no_prompt "The patch could not be fully applied with index updates.  Would you like to re-try applying the patch without the index update option? (y/n): " "y" re_apply_patch
    if [ "${re_apply_patch}" = "y" ]; then
      execute_command "git apply --ignore-whitespace ${diff_patch_file_name}" "" "" ""
    fi
  fi
}

function list_branches
{
  cd ${build_base_directory}

  git branch
  echo ""
  git branch -r
}

function debug_test_prompt_branch_params
{
  test_index="0"
  test_extra_prompt=""
  while [ "${test_index}" != "-100" ]; do
    prompt_branch "${1}"  "${2}" "${3}"  "${4}"  "${5}" "${6}"  test_index test_name "${test_extra_prompt}"

    echo ""
    echo "test_index = \"${test_index}\""
    echo "test_name  = \"${test_name}\""
    echo ""

    test_extra_prompt="Break out of the loop"
  done
}

function debug_test_yes_no_prompt
{
  debug_yes_no_continue="y"
  while [ "${debug_yes_no_continue}" = "y" ]; do
    yes_no_prompt "Yes No Prompt with Y default (y/n):" "Y" debug_test_yn_sel_value
    echo "  You entered: \"${debug_test_yn_sel_value}\""
    yes_no_prompt "Yes No Prompt with N default (y/n):" "N" debug_test_yn_sel_value
    echo "  You entered: \"${debug_test_yn_sel_value}\""
    yes_no_prompt "Yes No Prompt with ( default (y/n):" ")" debug_test_yn_sel_value
    echo "  You entered: \"${debug_test_yn_sel_value}\""
    yes_no_prompt "Yes No Prompt with <no> default (y/n):" "" debug_test_yn_sel_value
    echo "  You entered: \"${debug_test_yn_sel_value}\""
    yes_no_prompt "This is a really long piece of text to test the formatting to see if it will work.  The formatting has been tested pretty widely so far already, but we need to test it to be sure that it is applied.${return_line}${return_line}Of course, once applied, we need to test it on the file prompt.  Are you happy with the formatted text?  If so, please press yes, if not, press no.  (y/n):" "" debug_test_yn_sel_value
    echo "  You entered: \"${debug_test_yn_sel_value}\""

    echo ""
    yes_no_prompt "Would you like to run the tests again? (y/n):" "" debug_yes_no_continue
  done
}

function debug_test_split_cucumber_line
{
  split_failed_line "cucumber -p firefox -p target-local -p no-manual-tests -p no-stage-tests -p no-wip-tests -p browser-firefox -p standard features/platform/contacts/contact_detail.feature:45# Scenario: User cannot save<new_line>Second line<new_line>Third line" test_split_scenario_cucumber test_split_scenario_description
  echo "test_split_scenario_cucumber:\"${return_line}${test_split_scenario_cucumber}\"${return_line}End"
  echo "test_split_scenario_description:\"${return_line}${test_split_scenario_description}\"${return_line}End"
}

function debug_test_test_reporting
{
  declare -a testing_feature_failed_folders
  declare -a testing_feature_failed_lines
  declare -a testing_rspec_failed_lines
  declare -a debug_test_reporting_missing_steps

  if [ -f ${build_parent_directory}/BuildLogs/rspec_test.txt ]; then
    if [ -f ${build_parent_directory}/BuildLogs/rspec_test_copy.txt ]; then
      rm ${build_parent_directory}/BuildLogs/rspec_test_copy.txt
    fi
    cp ${build_parent_directory}/BuildLogs/rspec_test.txt ${build_parent_directory}/BuildLogs/rspec_test_copy.txt
    check_rspec_test_run "sparrow_crm" ${build_parent_directory}/BuildLogs/rspec_test_copy.txt testing_rspec_success testing_rspec_failed_lines
    if [ -f ${build_parent_directory}/BuildLogs/rspec_test_copy.txt ]; then
      rm ${build_parent_directory}/BuildLogs/rspec_test_copy.txt
    fi
    echo "testing_rspec_success = \"${testing_rspec_success}\""

    test_test_index=0
    while [ ${test_test_index} -lt ${#testing_rspec_failed_lines[@]} ]; do
      echo "testing_rspec_failed_lines [${test_test_index}] = \"${testing_rspec_failed_lines[${test_test_index}]}\""
      test_test_index=$((${test_test_index} + 1))
    done
  fi

  if [ -f ${build_parent_directory}/BuildLogs/feature_test.txt ]; then
    if [ -f ${build_parent_directory}/BuildLogs/feature_test_copy.txt ]; then
      rm ${build_parent_directory}/BuildLogs/feature_test_copy.txt
    fi
    cp ${build_parent_directory}/BuildLogs/feature_test.txt ${build_parent_directory}/BuildLogs/feature_test_copy.txt
    test_smoke_fails "parrow_crm" ${build_parent_directory}/BuildLogs/feature_test_copy.txt testing_feature_success testing_feature_failed_folders testing_feature_failed_lines testing_rspec_failed_lines debug_test_reporting_missing_steps

    if [ -f ${build_parent_directory}/BuildLogs/feature_test_copy.txt ]; then
      rm ${build_parent_directory}/BuildLogs/feature_test_copy.txt
    fi

    echo "testing_feature_success = \"${testing_feature_success}\""
    test_test_index=0
    while [ ${test_test_index} -lt ${#testing_feature_failed_folders[@]} ]; do
      echo "testing_feature_failed_folders [${test_test_index}] = \"${testing_feature_failed_folders[${test_test_index}]}\""
      test_test_index=$((${test_test_index} + 1))
    done
    test_test_index=0
    while [ ${test_test_index} -lt ${#testing_feature_failed_lines[@]} ]; do
      echo "testing_feature_failed_lines [${test_test_index}] = \"${testing_feature_failed_lines[${test_test_index}]}\""
      test_test_index=$((${test_test_index} + 1))
    done
  fi

  declare -a testing_array_types
  declare -a testing_array_files
  declare -a testing_array_sub_files
  declare -a testing_retest_results
  testing_failed="true"
  test_test_index=0
  while [ ${test_test_index} -lt ${#testing_feature_failed_lines[@]} ]; do
    testing_failed_line="${testing_feature_failed_lines[${test_test_index}]}"

    if [ "cucumber " = "${testing_failed_line:0:9}" ]; then
      append_array_value testing_retest_results "${testing_failed}"
      if [ "${testing_failed}" = "true" ]; then
        testing_failed="false"
      else
        testing_failed="true"
      fi
    fi

    test_test_index=$((${test_test_index} + 1))
  done

  testing_array_types[${#testing_array_types[@]}]="full"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="ci smoke"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="ci cucumber"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="guard"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]="features/platform/contacts/addresses.feature"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="parrow_crm"
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]="features/platform/contacts/emails.feature"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="parrow_crm"
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]="features/platform/contacts/linkedin.feature"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="parrow_crm"
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]="features/platform/contacts/phones.feature"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="parrow_crm"
  testing_array_types[${#testing_array_types[@]}]="feature"
  testing_array_files[${#testing_array_files[@]}]="features/platform/social/social_media_settings.feature"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="parrow_crm"
  testing_array_types[${#testing_array_types[@]}]="rspec"
  testing_array_files[${#testing_array_files[@]}]=""
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="rspec"
  testing_array_files[${#testing_array_files[@]}]="sparrow_crm"
  testing_array_sub_files[${#testing_array_sub_files[@]}]=""
  testing_array_types[${#testing_array_types[@]}]="rspec"
  testing_array_files[${#testing_array_files[@]}]="sparrow_crm"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="controllers/sparrow_crm/fred.rb"
  testing_array_types[${#testing_array_types[@]}]="rspec"
  testing_array_files[${#testing_array_files[@]}]="sparrow_crm"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="controllers/sparrow_crm/linked_in_controller_spec.rb"
  testing_array_types[${#testing_array_types[@]}]="rspec"
  testing_array_files[${#testing_array_files[@]}]="sparrow_crm"
  testing_array_sub_files[${#testing_array_sub_files[@]}]="controllers/sparrow_crm/member_test.rb"

  report_test_success ${build_parent_directory}/BuildLogs/build_project_debug_report.txt "${testing_rspec_success}" testing_feature_failed_folders[@] testing_feature_failed_lines[@] testing_retest_results[@] testing_rspec_failed_lines[@] testing_array_types[@] testing_array_files[@] testing_array_sub_files[@] debug_test_reporting_missing_steps[@]

  if [ -f ${build_parent_directory}/BuildLogs/build_project_debug_report.txt ]; then
    rm ${build_parent_directory}/BuildLogs/build_project_debug_report.txt
  fi
}

function debug_test_stash_list
{
  show_stash_list_menu "The following stashes were made against this branch:" "" "false" delete_stash_sel "" "B-03907-actions_on_linkedin_feeds"
  echo "delete_stash_sel = \"${return_line}${delete_stash_sel}\"${return_line}end"
}

function debug_test_format_line
{
  format_line_for_menu "1" "" "This is the menu text${return_line}which will appear${return_line}on multiple lines.${return_line}To see if it will wrap properly." formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  format_line "   1) This/is/a/really/long/directory/path/that/needs/to/wrap/but/should/wrap/on/the/slash/so/that/I/can/confirm/that/the/slash/split/works and I want to test it with spaces to see what happens in a long sentance of stuff, so I will be \"copying\" the 'path' again here: This/is/a/really/long/directory/path/that/needs/to/wrap/but/should/wrap/on/the/slash/so/that/I/can/confirm/that/the/slash/split/works" "      " formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  format_line_with_prefix "   1) " "This/is/a/really/long/directory/path/that/needs/to/wrap/but/should/wrap/on/the/slash/so/that/I/can/confirm/that/the/slash/split/works and I want to test it with spaces to see what happens in a long sentance of stuff, so I will be copying the path again here: This/is/a/really/long/directory/path/that/needs/to/wrap/but/should/wrap/on/the/slash/so/that/I/can/confirm/that/the/slash/split/works" "      " formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  format_line "This is a realy long line of text that needs formatting, I want to break it if I can, so I am including an apostrophe ('), and a quote [\"].  I think that this should break it." "" formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  format_line_for_menu "1" "" "Text for a menu (') [\"]" formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  split_failed_line "Left text to split (') [\"] # Scenario: Right text to split (') [\"]" formatted_debug_line formatted_debug_line_2
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  echo "formatted_debug_line_2:\"${return_line}${formatted_debug_line_2}\"${return_line}End"
  ltrim_line "       Text to trim (') [\"]" formatted_debug_line
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  split_line_on_char "Left text to split (') [\"]:Right text to split (') [\"]" ":" formatted_debug_line formatted_debug_line_2
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  echo "formatted_debug_line_2:\"${return_line}${formatted_debug_line_2}\"${return_line}End"
  split_feature_file_name "./Left text to split (') [\"]/Right text to split (') [\"]" formatted_debug_line formatted_debug_line_2
  echo "formatted_debug_line:\"${return_line}${formatted_debug_line}\"${return_line}End"
  echo "formatted_debug_line_2:\"${return_line}${formatted_debug_line_2}\"${return_line}End"
}

function debug_test_prompt_branch
{
  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "false" "true"  "true"  "Initial prompt" "(12) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "true"  "true"  "true"  "Initial prompt" "(11) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "false" "true"  "true"  "true"  "Initial prompt" "(10) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "false" "false" "true"  "Initial prompt" "( 9) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "true"  "false" "true"  "Initial prompt" "( 8) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "false" "true"  "false" "true"  "Initial prompt" "( 7) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "false" "true"  "false" "Initial prompt" "( 6) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "true"  "true"  "false" "Initial prompt" "( 5) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "false" "true"  "true"  "false" "Initial prompt" "( 4) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "false" "false" "false" "Initial prompt" "( 3) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "true"  "true"  "false" "false" "Initial prompt" "( 2) What do you want? "

  # prompt                          loc     rem     mst     def   prompt           ask
  debug_test_prompt_branch_params "false" "true"  "false" "false" "Initial prompt" "( 1) What do you want? "
}

function debug_test_show_parameter_values
{
  # show the values of all of the passed in parameters...
  max_len_var_name=0
  build_index=0
  while [ "${build_index}" -lt "${#command_options[@]}" ]; do
    cmd_values=(${command_vars[${build_index}]})
    cmd_index=0
    while [ "${cmd_index}" -lt "${#cmd_values[@]}" ]; do
      if [ ${max_len_var_name} -lt ${#cmd_values[${cmd_index}]} ]; then
        max_len_var_name="${#cmd_values[${cmd_index}]}"
      fi
      cmd_index=$((${cmd_index} + 1))
    done

    build_index=$((${build_index} + 1))
  done

  debug_spaces="                                                "
  debug_spaces="${debug_spaces:0:${max_len_var_name}}"
  build_index=0
  while [ "${build_index}" -lt "${#command_options[@]}" ]; do
    echo "Command ${command_options[${build_index}]}:"

    cmd_values=(${command_vars[${build_index}]})
    cmd_index=0
    while [ "${cmd_index}" -lt "${#cmd_values[@]}" ]; do
      eval "debug_test_val=\"\${${cmd_values[${cmd_index}]}}\""
      echo "  ${cmd_values[${cmd_index}]}${debug_spaces:0:${#debug_spaces} - ${#cmd_values[${cmd_index}]} + 1}= \"${debug_test_val}\""
      cmd_index=$((${cmd_index} + 1))
    done

    build_index=$((${build_index} + 1))
  done
}

function debug_test_execute_command
{
  execute_command "echo \"This is a test\"" "${build_parent_directory}/BuildLogs/echo_test.txt" echo_test_success echo_test_text
  echo "echo_test_success = \"${echo_test_success}\""
  echo "echo_test_text = \"${echo_test_text}\""

  execute_command "echo 'This is a test'" "${build_parent_directory}/BuildLogs/echo_test.txt" echo_test_success echo_test_text
  echo "echo_test_success = \"${echo_test_success}\""
  echo "echo_test_text = \"${echo_test_text}\""
}

function debug_file_changed
{
  has_file_changed "${build_base_directory}/sparrow_crm/Gemfile" test_file_changed
  echo "test_file_changed = \"${test_file_changed}\" (true?)"
  archive_file "${build_base_directory}/sparrow_crm/Gemfile"
  has_file_changed "${build_base_directory}/sparrow_crm/Gemfile" test_file_changed
  echo "test_file_changed = \"${test_file_changed}\" (false?)"
  echo "Fred" >> ${build_log_directory}/archive/sparrow_crm/Gemfile
  has_file_changed "${build_base_directory}/sparrow_crm/Gemfile" test_file_changed
  echo "test_file_changed = \"${test_file_changed}\" (true?)"
  archive_file "${build_base_directory}/sparrow_crm/Gemfile"
  has_file_changed "${build_base_directory}/sparrow_crm/Gemfile" test_file_changed
  echo "test_file_changed = \"${test_file_changed}\" (false?)"
  rm ${build_log_directory}/archive/sparrow_crm/Gemfile
}

function debug_build_sub_directory
{
  if [ -f ${build_log_directory}/debug_test_log.txt ]; then
    rm ${build_log_directory}/debug_test_log.txt
  fi
  build_sub_folder "${build_base_directory}" "sparrow_host" "test" "false" "false" "${build_log_directory}/debug_test_log.txt"
  if [ -f ${build_log_directory}/debug_test_log.txt ]; then
    rm ${build_log_directory}/debug_test_log.txt
  fi
}

function debug_append_array
{
  declare -a test_passing_array_var

  append_array_value test_passing_array_var "When /^I view the Facebook feed$/ do"
  append_array_value test_passing_array_var "This is a sample value to append to an array"
  append_array_value test_passing_array_var "It's a miracle that this works!"
  append_array_value test_passing_array_var "echo \"This is a test\""
  append_array_value test_passing_array_var "echo \\\"This is \${fred} a test\\\""
  append_array_value test_passing_array_var "This \"test\", it's all about
testing quotes (\") and apostrophes (') in multiple lines.

So, how about a quote?
\"It's not proper to quote stupid things.\"

Of course that's not a \"quote\", but that's cool."

  echo "test_passing_array_var.length = \"${#test_passing_array_var[@]}\""
  test_array_index=0
  while [ ${test_array_index} -lt ${#test_passing_array_var[@]} ]; do
    echo "test_passing_array_var [${test_array_index}] = \"${test_passing_array_var[${test_array_index}]}\""
    test_array_index=$((${test_array_index} + 1))
  done
}

function debug_extract_db_information
{
  declare -a sections_array_debug
  declare -a adapters_array_debug
  declare -a databases_array_debug
  declare -a usernames_array_debug
  declare -a passwords_array_debug

  extract_db_configurations "${build_base_directory}/sparrow_host" sections_array_debug adapters_array_debug databases_array_debug usernames_array_debug passwords_array_debug

  sections_index_debug=0
  while [ ${sections_index_debug} -lt ${#sections_array_debug[@]} ]; do
    echo "sections_array_debug [${sections_index_debug}] = ${sections_array_debug[${sections_index_debug}]}"
    echo "adapters_array_debug [${sections_index_debug}] = ${adapters_array_debug[${sections_index_debug}]}"
    echo "databases_array_debug [${sections_index_debug}] = ${databases_array_debug[${sections_index_debug}]}"
    echo "usernames_array_debug [${sections_index_debug}] = ${usernames_array_debug[${sections_index_debug}]}"
    echo "passwords_array_debug [${sections_index_debug}] = ${passwords_array_debug[${sections_index_debug}]}"

    sections_index_debug=$((${sections_index_debug} + 1))
  done
}

function debug_heroku_run
{
  cd ${build_base_directory}
  if git remote | grep -q "heroku"; then
    heroku_run "rake db:migrate" "${build_log_directory}/heroku_deploy.txt"
    heroku_run "rake db:seed" "${build_log_directory}/heroku_deploy.txt"
  else
    echo "Canot run the heroku tests."
  fi
}

process_command_lines command_line_arguments[@]

record_version "${0}"

clear_log_histories

if [ "${debug_mode}" = "true" ]; then
  record_history "  # Debug Test"

  ####
  # I think tests are important, and I don't want to loose the tests, but I don't want
  # to run all of the tests all of the time.
  # So I create the tests, run them, then once they pass, I comment them out.
  # If I need them again, I can put them back.
  # I have grouped the tests into functional groupings.
  ####

  # debug_test_prompt_branch
  # debug_test_yes_no_prompt
  # debug_test_format_line
  # debug_test_stash_list
  # debug_test_test_reporting
  # debug_test_split_cucumber_line
  # debug_test_show_parameter_values
  # debug_test_execute_command
  # debug_file_changed
  # debug_build_sub_directory
  # debug_append_array
  # debug_extract_db_information
  # debug_heroku_run

  record_history "  ###### Debug Test Done"
  exit 1
fi

# --smoke-params                - Parameters to pass into the smoke
# if [ "${do_set_smoke_params}" = "true" ]; then
#   # user_smoke_params
#   # Nothing to do here, we just use the param if it is set.
#   # if not, we set it in the set_default_param_values...
# fi

# --test_params --test-params   - Parameters for running the menuized tests in the form of "<test number>[:<line_number>]"
if [ "${use_menu_test_parameters}" = "true" ]; then
  # menu_test_param_value
  split_line_on_char "${menu_test_param_value}" ":" test_param_test_number test_param_test_line
fi

set_default_param_values

# -?, --help                    - Show help
if [ "${show_help}" = "true" ]; then
  prompt_commands_or_help "true"
  exit 0
fi

# --base_dir --base-dir         - The base directory to work in (the parent to the project)
if [ "${set_base_dir}" = "true" ]; then
  # Set the base directory based on passed in parameters.
  # This was created/added to allow simplified SSH scripting.  Probably not really needed...
  # (If I was more sure of what I am doing)
  #
  # At this time, it is probably mostly useless, but there isn't a reall good reason to remove
  # it.

  cd ${base_dir_param}
  current_directory="$(pwd)"
  build_base_directory="${current_directory}/${project_base_name}"
  build_parent_directory="${current_directory}"
  build_log_directory="${build_parent_directory}/BuildLogs"
fi

# --reset-build-cache           - Reset the cache of build information to force the bundle instal to run.
if [ "${do_reset_build_cache_files}" = "true" ]; then
  rm -rf ${build_log_directory}/archive
fi

# --rails_env --rails-env       - The RAILS_ENV to use for build/deploy
if [ "${change_rails_env}" = "true" ]; then
  # Allow a parameter to set the environment to use other than the script default
  # of development.

  rails_env_to_use="${rails_env_param}"
fi

# -v, --move                    - Move the current git directory out of the way
if [ "${do_move_site}" = "true" ]; then
  move_build_base_directory
fi

# -l, --clone                   - Clone the repository
if [ "${do_clone}" = "true" ]; then
  clone_repository
fi

# --check-merge --check_merge   - Uses git-status to validate/check/add and finally commit files with merge conflicts
if [ "${do_merge_validation}" = "true" ]; then
  validate_merge_conflicts continue_after_merge
fi

# --patch                       - Create a patch file
if [ "${do_create_patch}" = "true" ]; then
  show_create_patch_menu
fi

# ---stash                      - Menuized version of git stash
if [ "${do_stash_menu}" = "true" ]; then
  show_stash_menu
fi

# --stash                       - Stash the current branch
if [ "${do_stash_command}" = "true" ]; then
  stash_changes "" ""
fi

# --drop_stash --drop-stash     - Drop a stash
if [ "${do_stash_drop}" = "true" ]; then
  prompt_drop_stash
fi

# --unstash                     - Apply a stash
if [ "${do_stash_unstash}" = "true" ]; then
  prompt_apply_stash "" applied_stash
fi

# --reset_git --reset-git       - Do a hard reset
if [ "${do_git_reset}" = "true" ]; then
  hard_reset_repository "true" hard_reset_success
fi

# --clean                       - Do a clean of the git repository...
if [ "${do_database_clean}" = "true" ]; then
  clean_repository
fi

# -s, --switch                  - Switch branches
if [ "${do_switch}" = "true" ]; then
  switch_branch
fi

# --db-branch --db_branch       - Configure wether or not the database is branched as well.
if [ "${do_database_branching}" = "true" ]; then
  branch_database_menu
fi

# -m, --merge                   - Merge a branch
if [ "${do_merge}" = "true" ]; then
  merge_branch
fi

# --apply-patch                 - Apply a patch to the current branch.
if [ "${do_apply_patch}" = "true" ]; then
  apply_patch_file
fi

# -p, --pull                    - Pull the source
if [ "${do_pull_source}" = "true" ]; then
  pull_project_source project_get_updated

  # if [ "${project_get_updated}" = "true" ]; then
  #   do_build_project="true"
  # fi
fi

# --db-dump --db_dump           - Drop the test databases and recreate them to dump the schema into the schema.rb file.
if [ "${do_schema_recreate}" = "true" ]; then
  recreate_database_schema
fi

# -e, --reset_db --reset-db     - Delete and reset/recreate DBs
if [ "${do_reset_db}" = "true" ]; then
  reset_databases "${rails_env_to_use}"
fi

# --stash_locks --stash-locks   - Backup the Gemfile.lock files that are not checked in
if [ "${do_stash_lockfiles}" = "true" ]; then
  stash_lock_files
fi

# -b, --build                   - Build the project
if [ "${do_build_project}" = "true" ]; then
  build_project
fi

# -t, --test                    - Run tests
if [ "${do_run_tests}" = "true" ]; then
  test_store_test_param_test_number="${test_param_test_number}"
  test_store_test_param_test_line="${test_param_test_line}"
  test_param_test_number="0"

  show_test_menu

  test_param_test_number="${test_store_test_param_test_number}"
  test_param_test_line="${test_store_test_param_test_line}"
fi

# --smoke                       - Do a partial test of only running the ci:smoke.
if [ "${do_cucumber_smoke}" = "true" ]; then
  test_store_test_param_test_number="${test_param_test_number}"
  test_store_test_param_test_line="${test_param_test_line}"
  test_param_test_number="1"

  show_test_menu

  test_param_test_number="${test_store_test_param_test_number}"
  test_param_test_line="${test_store_test_param_test_line}"
fi

# ---test                       - Menuized testing options
if [ "${do_test_menu}" = "true" ]; then
  show_test_menu
fi

# -c, --console                 - Run the Rails console
if [ "${do_launch_console}" = "true" ]; then
  launch_rails_console
fi

# -h, --push                    - Push committed changes to GitHub
if [ "${do_push_source}" = "true" ]; then
  push_source
fi

# -n, --new_branch --new-branch - Create a branch
if [ "${do_create_branch}" = "true" ]; then
  create_branch
fi

# -d, --delete                  - Delete a branch
if [ "${do_delete_branch}" = "true" ]; then
  delete_branch
fi

# -u, --status                  - Just do a git status on the current branch...
if [ "${do_show_status}" = "true" ]; then
  get_current_status
fi

# -y --deploy                   - Deploy the system to one of the known machines
if [ "${do_deploy}" = "true" ]; then
  deploy_system
fi

# -g, --guard                   - Launch Gaurd continuous testing
if [ "${do_start_guard}" = "true" ]; then
  show_guard_menu
fi

# -r, --run                     - Run the application
if [ "${do_run_site}" = "true" ]; then
  run_site
fi

# -o, --production              - Production Deployment
if [ "${do_production_deployment}" = "true" ]; then
  deploy_to_production
fi

# --history                     - Show recent history
if [ "${do_show_history}" = "true" ]; then
  show_history
fi

# --list                        - List branches
if [ "${do_list_branches}" = "true" ]; then
  list_branches
fi

record_history "  ### Done ###"
cd ${current_directory}

update_build_project

exit 0

# version=0.0.49
